<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react-redux中@connect用法</title>
      <link href="/2019/07/29/react-redux%E4%B8%AD-connect%E7%94%A8%E6%B3%95/"/>
      <url>/2019/07/29/react-redux%E4%B8%AD-connect%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>忘记subscribe，记住reducer，action和dispatch即可</p></blockquote><h2 id="React-redux具体使用"><a href="#React-redux具体使用" class="headerlink" title="React-redux具体使用"></a>React-redux具体使用</h2><p>Provider组件在应用最外层，传入store即可，只用一次<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="comment">//导入reducer 和actionCreator</span></span><br><span class="line"><span class="keyword">import</span> &#123;counter&#125; <span class="keyword">from</span> <span class="string">'./index.redux.js'</span></span><br><span class="line"><span class="comment">//导入createStore 的方法从redux当中  并且从redux当中导入处理中间件的方法applyMiddleware</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore,applyMiddleware,compose&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="comment">//这里导入处理redux的中间件专门处理redux的异步问题 因为本身redux是同步的</span></span><br><span class="line"><span class="comment">//导入react-redux中的provider</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="comment">/**使用createStor(reducer)方法生成store </span></span><br><span class="line"><span class="comment">  * 添加applyMiddleware(thunk)方法来处理thunk中间件来达到处理异步的效果</span></span><br><span class="line"><span class="comment">  * compose是用来组合createStore当中的多个方法</span></span><br><span class="line"><span class="comment">  */</span>   </span><br><span class="line"><span class="keyword">const</span> store= createStore(counter,compose(</span><br><span class="line">    applyMiddleware(thunk),</span><br><span class="line">    <span class="built_in">window</span>.devToolsExtension?<span class="built_in">window</span>.devToolsExtension():<span class="function"><span class="params">f</span> =&gt;</span>f</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">(    <span class="comment">//这里store 只需要在Provider上传入一次即可</span></span><br><span class="line">  &lt;Provider store=&#123;store&#125; &gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">),</span></span><br><span class="line"><span class="regexp">document.getElementById('root'))</span></span><br></pre></td></tr></table></figure></p><p>Connect负责从外部获取组件需要的参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;add_A,rem_R,addAsync&#125; <span class="keyword">from</span> <span class="string">'./index.redux.js'</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;现在是数字几&#123;<span class="keyword">this</span>.props.num&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>*使用了connect之后这里不需要在手动的dispatch了直接调用即可*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.props.add_A&#125;&gt;加&lt;/</span>button&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.props.rem_R&#125;&gt;减&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>*这里点击完成之后就会触发异步方法 在两秒之后更新*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.props.addAsync&#125;&gt;等两秒再加&lt;/</span>button&gt;</span><br><span class="line">             &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/接收store赋值给组件内部的props</span></span><br><span class="line"><span class="regexp">const mapStatetoProps = (state) =&gt;&#123;</span></span><br><span class="line"><span class="regexp">    return &#123;num:state&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/将store当中的所有的actionCreator放入actionCreators</span></span><br><span class="line"><span class="regexp">const actionCreators = &#123;add_A,rem_R,addAsync&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/将App传入connect当中 将所有的函数和参数都给到App 生成一个新的App 组件内部通过this.props即可获取 传入的参数和方法</span></span><br><span class="line"><span class="regexp">App = connect(mapStatetoProps,actionCreators)(App)</span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure></p><p>这份代码是actionCreator和reducer 主要改变的代码都在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.reduer.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建常量</span></span><br><span class="line"><span class="keyword">const</span> ADD_N = <span class="string">"加"</span></span><br><span class="line"><span class="keyword">const</span> REM_N = <span class="string">"减"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建reducer 根据老的state和action 生成新的state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counter=<span class="function">(<span class="params">state=<span class="number">0</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_N:</span><br><span class="line">            <span class="keyword">return</span> state+<span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> REM_N:</span><br><span class="line">            <span class="keyword">return</span> state<span class="number">-1</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="number">10</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//action creator</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add_A=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:ADD_N&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> rem_R=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:REM_N&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addAsync=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这里返回的是一个箭头函数 因为只有dispatch一个参数所以省略括号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//这里的方法回两秒之后执行</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//两秒之后执行dispatch发布add_A这个actionCreator </span></span><br><span class="line">            dispatch(add_A())</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="connect注解"><a href="#connect注解" class="headerlink" title="@connect注解"></a>@connect注解</h2><p>使用装饰器优化connect代码</p><ul><li><p>弹出个性化配置(因为很多的配置被react的脚手架隐藏了起来 这一步就是了展开，这个操作是不可逆的)<br>$ Npm run eject</p></li><li><p>安装依赖的插件<br>$ npm install babel-plugin-transform-decorators-legacy插件</p></li><li><p>完成上一步操作在Package.json里babel加上plugins配置 “plugins”:[“transform-decorators-legacy”]</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"babel"</span>: &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"react-app"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>:[<span class="string">"transform-decorators-legacy"</span>]   </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>上面的步骤都完成了话就可以用@connect注解的方法来优化我们的App.js啦<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;add_A,rem_R,addAsync&#125; <span class="keyword">from</span> <span class="string">'./index.redux.js'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**没使用@conncet注解方式之前的实现</span></span><br><span class="line"><span class="comment"> * 接收store赋值给组件内部的props</span></span><br><span class="line"><span class="comment"> * const mapStatetoProps = (state) =&gt;&#123;</span></span><br><span class="line"><span class="comment"> *     return &#123;num:state&#125;</span></span><br><span class="line"><span class="comment"> *&#125;</span></span><br><span class="line"><span class="comment"> *将store当中的所有的actionCreator放入actionCreators</span></span><br><span class="line"><span class="comment"> *const actionCreators = &#123;add_A,rem_R,addAsync&#125;</span></span><br><span class="line"><span class="comment"> *将App传入connect当中 将所有的函数和参数都给到App 生成一个新的App 组件内部通过this.props即可获取 传入的参数和方法</span></span><br><span class="line"><span class="comment"> *App = connect(mapStatetoProps,actionCreators)(App)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用注解的方式修改state和组件之间的传值</span></span><br><span class="line">@connect(</span><br><span class="line">    <span class="comment">//你需要state当中的什么参数 取出来就会放到props相对的参数当中</span></span><br><span class="line">    state=&gt;(&#123;<span class="attr">num</span>:state&#125;),</span><br><span class="line">    <span class="comment">//你需要state当中的什么方法就可以写到下面的大括号中就能被放到props当中 并且会自动dispatch</span></span><br><span class="line">    &#123;add_A,rem_R,addAsync&#125;</span><br><span class="line">)</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;现在是数字几&#123;<span class="keyword">this</span>.props.num&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>*使用了connect之后这里不需要在手动的dispatch了直接调用即可*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.props.add_A&#125;&gt;加 &lt;/</span>button&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.props.rem_R&#125;&gt;减 &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>*这里点击完成之后就会触发异步方法 在两秒之后更新*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.props.addAsync&#125;&gt;等两秒再加 &lt;/</span>button&gt;</span><br><span class="line">             &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React创建组件的三种方式</title>
      <link href="/2019/07/17/React%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/07/17/React%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归;<br>具体的三种方式：</p><ul><li>函数式定义的无状态组件</li><li>es5原生方式React.createClass定义的组件</li><li>es6形式的extends React.Component定义的组件</li></ul><p>虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。</p><h2 id="无状态函数式组件"><a href="#无状态函数式组件" class="headerlink" title="无状态函数式组件"></a>无状态函数式组件</h2><p>创建无状态函数式组件形式是从React 0.14版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。具体的无状态函数式组件，其官方指出：</p><p>在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；<br>这种通过多个简单然后合并成一个大应用的设计模式被提倡。<br>无状态函数式组件形式上表现为一个只带有一个render方法的组件类，通过函数形式或者ES6 箭头 function的形式在创建，并且该组件是无state状态的。具体的创建形式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloComponent</span>(<span class="params">props, <span class="regexp">/* context */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;HelloComponent name="Sebastian" /&gt;, mountNode)</span><br></pre></td></tr></table></figure></p><p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p><ul><li>组件不会被实例化，整体渲染性能得到提升<br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li><li>组件不能访问this对象<br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件</li><li>组件无法访问生命周期的方法<br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li><li>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</li></ul><p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。</p><h2 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h2><p>React.createClass是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InputControlES5 = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;<span class="comment">//定义传入props中的属性各种类型</span></span><br><span class="line">        initialValue: React.PropTypes.string</span><br><span class="line">    &#125;,</span><br><span class="line">    defaultProps: &#123; <span class="comment">//组件默认的props对象</span></span><br><span class="line">        initialValue: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置 initial state</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//组件相关的状态对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            text: <span class="keyword">this</span>.props.initialValue || <span class="string">'placeholder'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="comment">//this represents react component instance</span></span><br><span class="line">            text: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Type something:</span><br><span class="line">                &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.text&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">InputControlES6.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    initialValue: React.PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">InputControlES6.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">    initialValue: ''</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></p><p>与无状态组件相比，React.createClass和后面要描述的React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，React.createClass形式自身的问题暴露出来：</p><ul><li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li><li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考《无状态组件(Stateless Component) 与高阶组件》(<a href="http://www.jianshu.com/p/63569386befc)。" target="_blank" rel="noopener">http://www.jianshu.com/p/63569386befc)。</a></li></ul><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><p>React.Component是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。将上面React.createClass的形式改为React.Component形式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputControlES6</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 initial state</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            text: props.initialValue || <span class="string">'placeholder'</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ES6 类中函数必须手动绑定</span></span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            text: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Type something:</span><br><span class="line">                &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">               value=&#123;<span class="keyword">this</span>.state.text&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">InputControlES6.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    initialValue: React.PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">InputControlES6.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">    initialValue: ''</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></p><h2 id="React-createClass与React-Component区别"><a href="#React-createClass与React-Component区别" class="headerlink" title="React.createClass与React.Component区别"></a>React.createClass与React.Component区别</h2><p>根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。</p><h3 id="函数this自绑定"><a href="#函数this自绑定" class="headerlink" title="函数this自绑定"></a>函数this自绑定</h3><p>React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用this.method即可，函数中的this会被正确设置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Contacts = React.createClass(&#123;  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// React Component instance</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contacts</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// null</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>当然，React.Component有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用method.bind(this)来完成绑定，还可以使用arrow function来绑定。拿上例的handleClick函数来说，其绑定可以有：(用户事件的this指向常常需要自己手动绑定)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 构造函数中绑定</span></span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用bind来绑定</span></span><br><span class="line">&lt;div onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;&lt;/div&gt; </span><br><span class="line"><span class="comment">//3. 使用箭头函数绑定</span></span><br><span class="line">&lt;div onClick=&#123;()=&gt;<span class="keyword">this</span>.handleClick()&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="组件属性类型propTypes及其默认props属性defaultProps配置不同"><a href="#组件属性类型propTypes及其默认props属性defaultProps配置不同" class="headerlink" title="组件属性类型propTypes及其默认props属性defaultProps配置不同"></a>组件属性类型propTypes及其默认props属性defaultProps配置不同</h3><p>React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。对应上面配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;<span class="comment">//类的静态属性</span></span><br><span class="line">        name: React.PropTypes.string</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;<span class="comment">//类的静态属性</span></span><br><span class="line">        name: <span class="string">''</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置<br>其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoItem = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123; <span class="comment">// as an object</span></span><br><span class="line">        name: React.PropTypes.string</span><br><span class="line">    &#125;,</span><br><span class="line">    getDefaultProps()&#123;   <span class="comment">// return a object</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">''</span>    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="组件初始状态state的配置不同"><a href="#组件初始状态state的配置不同" class="headerlink" title="组件初始状态state的配置不同"></a>组件初始状态state的配置不同</h3><p>React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="comment">// define this.state in constructor</span></span><br><span class="line">            isEditing: <span class="literal">false</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoItem = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// return an object</span></span><br><span class="line">    getInitialState()&#123; </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isEditing: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Mixins的支持不同"><a href="#Mixins的支持不同" class="headerlink" title="Mixins的支持不同"></a>Mixins的支持不同</h3><p>什么是Mixins?<br>Mixins(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过Mixins进该对象来达到代码复用。具体可以参考《React Mixin的前世今生》。<br>React.createClass在创建组件时可以使用mixins属性，以数组的形式来混合类的集合。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SomeMixin = &#123;  </span><br><span class="line">  doSomething() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Contacts = React.createClass(&#123;  </span><br><span class="line">  mixins: [SomeMixin],</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.doSomething(); <span class="comment">// use mixin</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>但是遗憾的是React.Component这种形式并不支持Mixins，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代Mixins,那就是Higher-Order Components，具体细节可以参考 这篇文章(<a href="https://leozdgao.me/chushi-hoc/" target="_blank" rel="noopener">https://leozdgao.me/chushi-hoc/</a>)</p><h2 id="如何选择哪种方式创建组件"><a href="#如何选择哪种方式创建组件" class="headerlink" title="如何选择哪种方式创建组件"></a>如何选择哪种方式创建组件</h2><p>由于React团队已经声明React.createClass最终会被React.Component的类形式所取代。但是在找到Mixins替代方案之前是不会废弃掉React.createClass形式。所以：</p><p>能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。<br>除此之外，创建组件的形式选择还应该根据下面来决定：</p><ul><li><p>只要有可能，尽量使用无状态组件创建形式。</p></li><li><p>否则（如需要state、生命周期方法等），使用<code>React.Component</code>这种es6形式创建组件</p></li></ul><p>补充一点</p><blockquote><p>无状态组件内部其实是可以使用ref功能的，虽然不能通过this.refs访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。</p></blockquote><p>例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestComp</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ref;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        &lt;div ref=&#123;(node) =&gt; ref = node&#125;&gt;</span><br><span class="line">            ...</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window.getComputedStyle方法的使用</title>
      <link href="/2019/07/12/window-getComputedStyle%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/07/12/window-getComputedStyle%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="getComputedStyle-用法"><a href="#getComputedStyle-用法" class="headerlink" title="getComputedStyle() 用法"></a>getComputedStyle() 用法</h2><p>document.defaultView.getComputedStyle(element[,pseudo-element]);<br>或者<br>window.getComputedStyle(element[,pseudo-element]);</p><p>首先是有两个参数，元素和伪类。第二个参数不是必须的，当不查询伪类元素的时候可以忽略或者传入 null。<br>使用示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> my_div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">let</span> style = <span class="built_in">window</span>.getComputedStyle(my_div, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p>关于 defaultView 引用一下 MDN 对于 defaultView 的描述:</p><h3 id="defaultView"><a href="#defaultView" class="headerlink" title="defaultView"></a>defaultView</h3><p>在许多在线的演示代码中，getComputedStyle 是通过 document.defaultView 对象来调用的。<br>大部分情况下，这是不需要的，因为可以直接通过 window 对象调用。但有一种情况，你必需要使用 defaultView，那是在 Firefox 3.6 上访问子框架内的样式 (iframe)。</p><p>而且除了在 IE8 浏览器中 document.defaultView === window 返回的是 false 外，其他的浏览器（包括 IE9 ）返回的都是 true。所以后面直接使用 window 就好，不用在输入那么长的代码了。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>getComputedStyle 返回的对象是 CSSStyleDeclaration 类型的对象。取数据的时候可以直接按照属性的取法去取数据，例如 style.backgroundColor。需要注意的是，返回的对象的键名是 css 的驼峰式写法，background-color -&gt; backgroundColor。</p><p>需要注意的是 float 属性，根据 《JavaScript 高级程序》所描述的情况 ，float 是 JS 的保留关键字。根据 DOM2 级的规范，取元素的 float 的时候应该使用 cssFloat。其实 chrome 和 Firefox 是支持 float 属性的，也就是说可以直接使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> float_property = <span class="built_in">window</span>.getComputedStyle.style; <span class="comment">// chrome 和 Firefox支持</span></span><br></pre></td></tr></table></figure></p><p>而在任何版本的 IE 中都不能这样使用，并且在 IE 8 中仅支持 styleFloat ，这个下面的兼容性问题中谈到。</p><h2 id="和-style-的异同"><a href="#和-style-的异同" class="headerlink" title="和 style 的异同"></a>和 style 的异同</h2><p>getComputedStyle 和 element.style 的相同点就是二者返回的都是 CSSStyleDeclaration 对象，取相应属性值得时候都是采用的 CSS 驼峰式写法，均需要注意 float 属性。<br>而不同点就是：</p><ul><li>element.style 读取的只是元素的内联样式，即写在元素的 style 属性上的样式；而 getComputedStyle 读取的样式是最终样式，包括了内联样式、嵌入样式和外部样式。</li><li>element.style 既支持读也支持写，我们通过 element.style 即可改写元素的样式。而 getComputedStyle 仅支持读并不支持写入。我们可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式<br>我们可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式。</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>关于 getComputedStyle 的兼容性问题，在 Chrome 和 Firefox 是支持该属性的，同时 IE 9 10 11 也是支持相同的特性的，IE 8并不支持这个特性。 IE 8 支持的是 element.currentStyle 这个属性，这个属性返回的值和 getComputedStyle 的返回基本一致，只是在 float 的支持上，IE 8 支持的是 styleFloat,这点需要注意。</p><p>下面这个函数，能够获取一个元素的任意 CSS 属性值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">element, attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(element.currentStyle) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.currentStyle[attr];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getComputedStyle(element, <span class="literal">false</span>)[attr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FullScreen-Api</title>
      <link href="/2019/07/12/FullScreen-Api/"/>
      <url>/2019/07/12/FullScreen-Api/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在HTML5中提供了一个全屏API：fullscreen，它不仅只用于video视频全屏，还可以用在其他HTML中一些dom元素上，如：div, img, canvas等，都是可以使其全屏的。</p></blockquote><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestFullscreen = <span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ele.requestFullscreen) &#123;</span><br><span class="line">    ele.requestFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.webkitRequestFullscreen) &#123;</span><br><span class="line">    ele.webkitRequestFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.mozRequestFullScreen) &#123;</span><br><span class="line">    ele.mozRequestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.msRequestFullscreen) &#123;</span><br><span class="line">    ele.msRequestFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Fullscreen API is not supported.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> exitFullscreen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.exitFullscreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.exitFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.webkitExitFullscreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.webkitExitFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.mozCancelFullScreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.mozCancelFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.msExitFullscreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.msExitFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Fullscreen API is not supported.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="/img/fullscreen.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解JavaScript中的macrotask和microtask</title>
      <link href="/2019/07/12/%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84macrotask%E5%92%8Cmicrotask/"/>
      <url>/2019/07/12/%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84macrotask%E5%92%8Cmicrotask/</url>
      
        <content type="html"><![CDATA[<h2 id="异步任务运行机制"><a href="#异步任务运行机制" class="headerlink" title="异步任务运行机制"></a>异步任务运行机制</h2><p>JavaScript有一个执行栈和任务队列</p><p>主线程依次执行代码 ，会将函数入栈，函数运行完毕后再将该函数出栈</p><p>那么遇到 WebAPI（例如：setTimeout, AJAX）这些函数时，这些函数会立即返回一个值，从而让主线程不会在此处阻塞。而真正的异步操作会由浏览器执行，浏览器会在这些任务完成后，将事先定义的回调函数推入主线程的 任务队列 中。</p><p>而主线程则会在 清空当前执行栈后，按照先入先出的顺序读取任务队列里面的任务。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 开始执行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>); <span class="comment">// 2. 打印字符串 "script start"</span></span><br><span class="line">setTimeout(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">// 5. 浏览器在 0ms 之后将该函数推入任务队列</span></span><br><span class="line">                                 <span class="comment">//    而到第5步时才会被主线程执行</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>); <span class="comment">// 6. 打印字符串 "setTimeout"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">);                       <span class="comment">// 3. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);   <span class="comment">// 4. 打印字符串 "script end"</span></span><br><span class="line"><span class="comment">// 5. 主线程执行栈清空，开始读取 任务队列 中的任务</span></span><br></pre></td></tr></table></figure></p><p>浏览器的异步任务的执行机制，核心点为：<br>异步任务是由浏览器执行的，不管是AJAX请求，还是setTimeout等 API，浏览器内核会在其它线程中执行这些操作，当操作完成后，将操作结果以及事先定义的回调函数放入 JavaScript 主线程的任务队列中<br>JavaScript 主线程会在执行栈清空后，读取任务队列，读取到任务队列中的函数后，将该函数入栈，一直运行直到执行栈清空，再次去读取任务队列，不断循环<br>当主线程阻塞时，任务队列仍然是能够被推入任务的。这也就是为什么当页面的 JavaScript 进程阻塞时，我们触发的点击等事件，会在进程恢复后依次执行。</p><h2 id="Macrotasks-和-Microtasks"><a href="#Macrotasks-和-Microtasks" class="headerlink" title="Macrotasks 和 Microtasks"></a>Macrotasks 和 Microtasks</h2><p>Macrotask 和 microtask 都是属于上述的异步任务中的一种</p><ul><li>macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering</li><li>microtasks: process.nextTick, Promises, Object.observe(废弃), MutationObserver<br>setTimeout 的 macrotask ,和 Promise 的 microtask 有什么不同呢？ 我们通过下面的代码来展现他们的不同点：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>在这里，setTimeout的延时为0，而Promise.resolve()也是返回一个被resolve了promise对象，即这里的then方法中的函数也是相当于异步的立即执行任务，那么他们到底是谁在前谁在后？<br>我们看看最终的运行结果（node 7.7.3)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"script start"</span></span><br><span class="line"><span class="string">"script end"</span></span><br><span class="line"><span class="string">"promise1"</span></span><br><span class="line"><span class="string">"promise2"</span></span><br><span class="line"><span class="string">"setTimeout"</span></span><br></pre></td></tr></table></figure></p><p>这里的运行结果是Promise的立即返回的异步任务会优先于setTimeout延时为0的任务执行。</p><p>原因是任务队列分为 macrotasks 和 microtasks，而Promise中的then方法的函数会被推入 microtasks 队列，而setTimeout的任务会被推入 macrotasks 队列。在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microtasks 队列清空。</p><p>而事件循环每次只会入栈一个 macrotask ，主线程执行完该任务后又会先检查 microtasks 队列并完成里面的所有任务后再执行 macrotask<br><img src="/img/js-yb.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  resolve(); </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>); </span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line"><span class="comment">//结果是：3 4 6 8 7 5 2 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json中dependencies和devDependencies的区别</title>
      <link href="/2019/07/11/package-json%E4%B8%ADdependencies%E5%92%8CdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/11/package-json%E4%B8%ADdependencies%E5%92%8CdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在我们使用npm下载各种三方库的时候，都会在package.json中生成devDependencies或者dependencies，那么对于这两者，到底有什么区别呢？</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>对于我们依赖的这些插件库，有的是我们开发所使用的，有的则是项目所依赖的。对于这个分界线，我们诞生了dependencies和devDependencies，具体却别如下：</p><ul><li>devDependencies：开发环境使用</li><li>dependencies：生产环境使用</li></ul><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>例如：webpack，gulp等打包工具，这些都是我们开发阶段使用的，代码提交线上时，不需要这些工具，所以我们将它放入devDependencies即可，但是像jquery这类插件库，是我们生产环境所使用的，所以如要放入dependencies，如果未将jquery安装到dependencies，那么项目就可能报错，无法运行，所以类似这种项目必须依赖的插件库，我们则必须打入dependencies中。</p><h2 id="npm简写指令"><a href="#npm简写指令" class="headerlink" title="npm简写指令"></a>npm简写指令</h2><ul><li>-P 相当于 –save-prod,添加dependencies里面的包。在 -D -O不存在时,-P就是默认值</li><li>-S 相当于 –save, 添加dependencies里面的包</li><li>-D 相当于 –save-dev,添加devDependencies里面的包</li><li>-O 相当于 –save-optional,添加在optionalDependencies里面的包</li><li>–no-save 阻止保存记录在dependencies中</li></ul>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决JavaScript拖动时触发点击事件的BUG</title>
      <link href="/2019/07/05/%E8%A7%A3%E5%86%B3JavaScript%E6%8B%96%E5%8A%A8%E6%97%B6%E8%A7%A6%E5%8F%91%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84BUG/"/>
      <url>/2019/07/05/%E8%A7%A3%E5%86%B3JavaScript%E6%8B%96%E5%8A%A8%E6%97%B6%E8%A7%A6%E5%8F%91%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84BUG/</url>
      
        <content type="html"><![CDATA[<h2 id="bug的原因"><a href="#bug的原因" class="headerlink" title="bug的原因"></a>bug的原因</h2><p>一个完整的click事件是包含</p><blockquote><p>mousedown,mouseup</p></blockquote><p>两个事件的，而拖拽一个元素时，包含下面三个事件：</p><blockquote><p>mousedown,mousemove,mouseup</p></blockquote><p>所以我们在拖拽一个元素结束后，如果此元素上面绑定了点击事件，就会同时触发元素的点击事件，用户体验度不好。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p> 仔细比较拖拽与点击事件，发现拖拽事件多了一个mousemove，我们可以从这个mousemove入手，点击事件时mousedown与mouseup触发时鼠标没有移动，而拖拽时鼠标移动了一定的距离，具体体现在px上。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>可以设定一个clickFlag变量，通过clickFlag来确定mousedown与mouseup到底是触发了点击事件还是拖动事件：</p><ul><li>mousedown时记录下鼠标的位置x1，y1</li><li>mouseup时记录下鼠标的位置x2，y2</li><li><p>判断两次位置是否一样或是相差小于一个定值（设为5px）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">Math</span>.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))</span><br></pre></td></tr></table></figure><p>当d=0或是小于5时，即可认定用户没有拖拽。此时clickFlag为true，可以触发点击事件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组reduce()方法</title>
      <link href="/2019/06/28/JS%E6%95%B0%E7%BB%84reduce%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/28/JS%E6%95%B0%E7%BB%84reduce%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>reduce()方法可以搞定的东西，for循环，或者forEach方法有时候也可以搞定，那为啥要用reduce()？这个问题，之前我也想过，要说原因还真找不到，唯一能找到的是：通往成功的道路有很多，但是总有一条路是最捷径的…</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>arr.reduce(callback,[initialValue])<br>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p><p>callback （执行数组中每个值的函数，包含四个参数）</p><pre><code>1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））2、currentValue （数组中当前被处理的元素）3、index （当前元素在数组中的索引）4、array （调用 reduce 的数组）</code></pre><p>initialValue （作为第一次调用 callback 的第一个参数。）</p><h2 id="实例解析-initialValue-参数"><a href="#实例解析-initialValue-参数" class="headerlink" title="实例解析 initialValue 参数"></a>实例解析 initialValue 参数</h2><p>先看第一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum);</span><br></pre></td></tr></table></figure><blockquote><p>打印结果：<br>1 2 1<br>3 3 2<br>6 4 3<br>[1, 2, 3, 4] 10</p></blockquote><p>这里可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。</p><p>再看第二个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;，<span class="number">0</span>) <span class="comment">//注意这里设置了初始值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr, sum);</span><br></pre></td></tr></table></figure></p><blockquote><p>打印结果：<br>0 1 0<br>1 2 1<br>3 3 2<br>6 4 3<br>[1, 2, 3, 4] 10</p></blockquote><p>这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。</p><p>结论：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</p><p>注意：如果这个数组为空，运用reduce是什么情况？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//报错，"TypeError: Reduce of empty array with no initial value"</span></span><br></pre></td></tr></table></figure></p><p>但是要是我们设置了初始值就不会报错，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;，<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [] 0</span></span><br></pre></td></tr></table></figure></p><p>所以一般来说我们提供初始值通常更安全</p><h2 id="reduce的简单用法"><a href="#reduce的简单用法" class="headerlink" title="reduce的简单用法"></a>reduce的简单用法</h2><p>当然最简单的就是我们常用的数组求和，求乘积了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)</span><br><span class="line"><span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x*y)</span><br><span class="line"><span class="built_in">console</span>.log( sum ); <span class="comment">//求和，10</span></span><br><span class="line"><span class="built_in">console</span>.log( mul ); <span class="comment">//求乘积，24</span></span><br></pre></td></tr></table></figure></p><h2 id="reduce的高级用法"><a href="#reduce的高级用法" class="headerlink" title="reduce的高级用法"></a>reduce的高级用法</h2><h3 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nameNum = names.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cur <span class="keyword">in</span> pre)&#123;</span><br><span class="line">    pre[cur]++</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    pre[cur] = <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(nameNum); <span class="comment">//&#123;Alice: 2, Bob: 1, Tiff: 1, Bruce: 1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pre.includes(cur))&#123;</span><br><span class="line">      <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="将二维数组转化为一维"><a href="#将二维数组转化为一维" class="headerlink" title="将二维数组转化为一维"></a>将二维数组转化为一维</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="将多维数组转化为一维"><a href="#将多维数组转化为一维" class="headerlink" title="将多维数组转化为一维"></a>将多维数组转化为一维</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">const</span> newArr = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>pre.concat(<span class="built_in">Array</span>.isArray(cur)?newArr(cur):cur),[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr(arr)); <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><h3 id="对象里的属性求和"><a href="#对象里的属性求和" class="headerlink" title="对象里的属性求和"></a>对象里的属性求和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'math'</span>,</span><br><span class="line">        score: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'chinese'</span>,</span><br><span class="line">        score: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'english'</span>,</span><br><span class="line">        score: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//60</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery判断iFrame是否加载完成</title>
      <link href="/2019/06/28/jquery%E5%88%A4%E6%96%ADiFrame%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/"/>
      <url>/2019/06/28/jquery%E5%88%A4%E6%96%ADiFrame%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>假设我们的网页里有这样一个iframe框架：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"IFrame"</span> <span class="attr">src</span>=<span class="string">"about:blank"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在我们动态的给上面这个iframe框架指定了src地址后，我们可以用下面这三种方法来判断页面是否加载完成：</p><h2 id="用jquery里的load来判断："><a href="#用jquery里的load来判断：" class="headerlink" title="用jquery里的load来判断："></a>用jquery里的load来判断：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iFrame=$(<span class="string">"#IFrame"</span>);      </span><br><span class="line">$iFrame.prop(<span class="string">"src"</span>,<span class="string">"http://www.aijquery.cn"</span>);    </span><br><span class="line">$iFrame.load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       </span><br><span class="line">    alert(<span class="string">"加载完毕"</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用onreadystatechange来判断："><a href="#使用onreadystatechange来判断：" class="headerlink" title="使用onreadystatechange来判断："></a>使用onreadystatechange来判断：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iFrame=$(<span class="string">"#IFrame"</span>);</span><br><span class="line">$iFrame.prop(<span class="string">"src"</span>,<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="comment">/*@aijquery@*/</span><span class="number">0</span>) &#123; <span class="comment">//如果不是IE，IE的条件注释  </span></span><br><span class="line">    $iFrame[<span class="number">0</span>].onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">        alert(<span class="string">"加载完毕"</span>); </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    $iFrame[<span class="number">0</span>].onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// IE下的节点都有onreadystatechange这个事件  </span></span><br><span class="line">        <span class="keyword">if</span> (iframe.readyState == <span class="string">"complete"</span>)&#123;  </span><br><span class="line">            alert(<span class="string">"加载完毕"</span>); </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用attachEvent来判断："><a href="#用attachEvent来判断：" class="headerlink" title="用attachEvent来判断："></a>用attachEvent来判断：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iFrame=$(<span class="string">"#IFrame"</span>);</span><br><span class="line">$iFrame.prop(<span class="string">"src"</span>,<span class="string">"http://www.360.cn"</span>);</span><br><span class="line"><span class="keyword">if</span> ($iFrame[<span class="number">0</span>].attachEvent)&#123;  </span><br><span class="line">      $iFrame[<span class="number">0</span>].attachEvent(<span class="string">"onload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// IE  </span></span><br><span class="line">          alert(<span class="string">"加载完毕"</span>); </span><br><span class="line">      &#125;);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      $iFrame[<span class="number">0</span>].onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 非IE  </span></span><br><span class="line">          alert(<span class="string">"加载完毕"</span>);  </span><br><span class="line">      &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转载自  <a href="http://www.aijquery.cn/Html/jqueryjiqiao/110.html" target="_blank" rel="noopener">jquery里判断iFrame框架是否加载完成的三种方法</a></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery的on()方法和off()方法</title>
      <link href="/2019/06/27/jquery%E7%9A%84on%E6%96%B9%E6%B3%95%E5%92%8Coff%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/27/jquery%E7%9A%84on%E6%96%B9%E6%B3%95%E5%92%8Coff%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自从jquery1.7以来，on事件添加到这个版本，使得事件的绑定变的十分简单，用过jquery的人相信对off，on方法爱不释手。下面是相关的on,off的使用语法:</p></blockquote><h2 id="on-使用场景"><a href="#on-使用场景" class="headerlink" title="on() 使用场景"></a>on() 使用场景</h2><h3 id="最简单的写法"><a href="#最简单的写法" class="headerlink" title="最简单的写法"></a>最简单的写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul li"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">  alert(<span class="string">"点击事件!"</span>);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="多个元素绑定相同事件"><a href="#多个元素绑定相同事件" class="headerlink" title="多个元素绑定相同事件"></a>多个元素绑定相同事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul li,div"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">  alert(<span class="string">"点击事件!"</span>);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="元素绑定多个事件"><a href="#元素绑定多个事件" class="headerlink" title="元素绑定多个事件"></a>元素绑定多个事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".demonstrate"</span>).on(&#123;  </span><br><span class="line">  mouseover:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">"over"</span>);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  mouseout:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    $(<span class="keyword">this</span>).removeClass(<span class="string">"over"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;,<span class="string">"ul li"</span>)</span><br></pre></td></tr></table></figure><h3 id="实现事件委托"><a href="#实现事件委托" class="headerlink" title="实现事件委托"></a>实现事件委托</h3><p>父元素ul li 给目标元素.demostrate添加事件,事件委托的好处是,目标元素可以是之前页面不存在到,后来加上去的也可以。<br>只需要考虑一个父元素就可以，给父元素添加委托事件，不用考虑子元素的数量什么的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul li"</span>).on(&#123;</span><br><span class="line">  click:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>,<span class="string">'1111'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  mouseover: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mouseover'</span>,<span class="string">'1111'</span>);</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">"over"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  mouseout: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).removeClass(<span class="string">"over"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="string">".demostrate"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h3><p>用法一</p><p>jQueryObject.on( events [, selector ] [, data ], handler )</p><p>用法二</p><p>jQueryObject.on( eventsMap [, selector ] [, data ] )</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>events    String类型一个或多个用空格分隔的事件类型和可选的命名空间，例如”click”、”focus click”、”keydown.myPlugin”。</li><li>eventsMap    Object类型一个Object对象，其每个属性对应事件类型和可选的命名空间(参数events)，属性值对应绑定的事件处理函数(参数handler)。</li><li>selector    可选/String类型一个jQuery选择器，用于指定哪些后代元素可以触发绑定的事件。如果该参数为null或被省略，则表示当前元素自身绑定事件(实际触发者也可能是后代元素，只要事件流能到达当前元素即可)。</li><li>data    可选/任意类型触发事件时，需要通过event.data传递给事件处理函数的任意数据。</li><li>handler    Function类型指定的事件处理函数。</li></ul><p>关于参数selector，你可以简单地理解为：如果该参数等于null或被省略，则为当前匹配元素绑定事件；否则就是为当前匹配元素的后代元素中符合selector选择器的元素绑定事件。</p><p>参数handler中的this指向当前匹配元素的后代元素中触发该事件的DOM元素。如果参数selector等于null或被省略，则this指向当前匹配元素(也就是该元素)。</p><p>on()还会为handler传入一个参数：表示当前事件的Event对象。</p><p>参数handler的返回值与DOM原生事件的处理函数返回值作用一致。例如”submit”(表单提交)事件的事件处理函数返回false，可以阻止表单的提交。</p><p>如果事件处理函数handler仅仅只为返回false值，可以直接将handler设为false。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>on()函数的返回值为jQuery类型，返回当前jQuery对象本身。</p><h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><p>on()函数并不是为当前jQuery对象匹配的元素绑定事件处理函数，而是为它们的后代元素中符合选择器selector参数的元素绑定事件处理函数。on()函数并不是直接为这些后代元素挨个绑定事件，而是委托给当前jQuery对象的匹配元素来处理。由于DOM 2级的事件流机制，当后代元素selector触发事件时，该事件会在事件冒泡中传递给其所有的祖辈元素，当事件流传递到当前匹配元素时，jQuery会判断是哪个后代元素触发了事件，如果该元素符合选择器selector，jQuery就会捕获该事件，从而执行绑定的事件处理函数。</p><h2 id="off-解绑事件"><a href="#off-解绑事件" class="headerlink" title="off() 解绑事件"></a>off() 解绑事件</h2><h3 id="最简单的写法-1"><a href="#最简单的写法-1" class="headerlink" title="最简单的写法"></a>最简单的写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul li"</span>).off(<span class="string">"click"</span>)</span><br></pre></td></tr></table></figure><h3 id="多个元素解绑相同事件"><a href="#多个元素解绑相同事件" class="headerlink" title="多个元素解绑相同事件"></a>多个元素解绑相同事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul li,div"</span>).off(<span class="string">"click"</span>)</span><br></pre></td></tr></table></figure><h3 id="元素解绑多个事件"><a href="#元素解绑多个事件" class="headerlink" title="元素解绑多个事件"></a>元素解绑多个事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".demonstrate"</span>).off(<span class="string">"mouseover mouseout"</span>,<span class="string">"ul li"</span>)</span><br></pre></td></tr></table></figure><h3 id="实现事件委托的解绑"><a href="#实现事件委托的解绑" class="headerlink" title="实现事件委托的解绑"></a>实现事件委托的解绑</h3><p>父元素ul li 给目标元素.demostrate移除事件,事件委托的好处是,目标元素可以是之前页面不存在到,后来加上去的也可以。<br>只需要考虑一个父元素就可以，给父元素移除委托事件，不用考虑子元素的数量什么的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul li"</span>).off(<span class="string">"click mouseover mouseout"</span>,<span class="string">".demostrate"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="具体用法-1"><a href="#具体用法-1" class="headerlink" title="具体用法"></a>具体用法</h3><p>用法一</p><p>jQueryObject.off( [ events [, selector ] [, handler ] ] )</p><p>用法二</p><p>jQueryObject.off( eventsMap [, selector ] )</p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>events    可选/String类型一个或多个用空格分隔的事件类型和可选的命名空间，例如”click”、”focus click”、”keydown.myPlugin”。</li><li>eventsMap    Object类型一个Object对象，其每个属性对应事件类型和可选的命名空间(参数events)，属性值对应绑定的事件处理函数(参数handler)。</li><li>selector    可选/String类型一个jQuery选择器，用于指定哪些后代元素可以触发绑定的事件。如果该参数为null或被省略，则表示当前元素自身绑定事件(实际触发者也可能是后代元素，只要事件流能到达当前元素即可)。</li><li>handler    可选/Function类型指定的事件处理函数。<br>off()函数将会移除当前匹配元素上为后代元素selector绑定的events事件的事件处理函数handler。</li></ul><p>如果省略参数selector，则移除为任何元素绑定的事件处理函数。</p><p>参数selector必须与通过on()函数添加绑定时传入的选择器一致。</p><p>如果省略参数handler，则移除指定元素指定事件类型上绑定的所有事件处理函数。</p><p>如果省略了所有参数，则表示移除当前元素上为任何元素绑定的任何事件类型的任何事件处理函数。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>off()函数的返回值为jQuery类型，返回当前jQuery对象本身。</p><p>实际上，off()函数的参数全是筛选条件，只有匹配所有参数条件的事件处理函数才会被移除。参数越多，限定条件就越多，被移除的范围就越小。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">btnClick1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert( <span class="keyword">this</span>.value + <span class="string">"-1"</span> );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">btnClick2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert( <span class="keyword">this</span>.value + <span class="string">"-2"</span> );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> $body = $(<span class="string">"body"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给按钮1绑定点击</span></span><br><span class="line">$body.on(<span class="string">"click"</span>, <span class="string">"#btn1"</span>, btnClick1 );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给按钮2绑定点击</span></span><br><span class="line">$body.on(<span class="string">"click"</span>, <span class="string">"#btn2"</span>, btnClick2 );</span><br><span class="line"> </span><br><span class="line"><span class="comment">//为所有a元素绑定click、mouseover、mouseleave事件</span></span><br><span class="line">$body.on(<span class="string">"click mouseover mouseleave"</span>, <span class="string">"a"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( event.type == <span class="string">"click"</span> )&#123;</span><br><span class="line">    $body.off(<span class="string">"click"</span>, <span class="string">"#btn1"</span>);<span class="comment">//取消btn1的绑定事件。成功执行</span></span><br><span class="line">    alert(<span class="string">"点击事件"</span>);</span><br><span class="line">    alert(<span class="string">"ddd"</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( event.type == <span class="string">"mouseover"</span> )&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">"color"</span>, <span class="string">"red"</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">"color"</span>, <span class="string">"blue"</span>);</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移除body元素为所有button元素的click事件绑定的事件处理函数btnClick2</span></span><br><span class="line"><span class="comment">// 点击按钮，btnClick1照样执行</span></span><br><span class="line">$body.off(<span class="string">"click"</span>, <span class="string">":button"</span>, btnClick2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 点击按钮1，不会执行任何事件处理函数</span></span><br><span class="line">$body.off(<span class="string">"click"</span>, <span class="string">"#btn1"</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 注意： $body.off("click", ":button"); 无法移除btn1的点击事件，off()函数指定的选择器必须与on()函数传入的选择器一致。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移除body元素为所有元素(包括button和&lt;a&gt;元素)的click事件绑定的所有处理函数</span></span><br><span class="line"><span class="comment">// 点击按钮或链接，都不会触发执行任何事件处理函数</span></span><br><span class="line">$(<span class="string">"body"</span>).off(<span class="string">"click"</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移除body元素为所有元素的任何事件绑定的所有处理函数</span></span><br><span class="line"><span class="comment">// 点击按钮，或点击链接或者鼠标移入/移出链接，都不会触发执行任何事件处理函数</span></span><br><span class="line">$(<span class="string">"body"</span>).off( );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrollIntoView</title>
      <link href="/2019/06/27/scrollIntoView/"/>
      <url>/2019/06/27/scrollIntoView/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DOM规范中并没有规定各浏览器需要实现怎样的滚动页面区域，各浏览器实现了相应的方法，可以使用不同的方式控制页面区域的滚动。这些方法作为HTMLElement类型的扩展存在，所以它能在所有元素上使用。</p><h2 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView()"></a>scrollIntoView()</h2><p>默认<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.scrollIntoView()  <span class="comment">//  滚动到可视范围顶端</span></span><br></pre></td></tr></table></figure></p><p>boolean值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.scrollIntoView(<span class="literal">true</span>)  <span class="comment">//  滚动到可视范围顶端</span></span><br><span class="line">element.scrollIntoView(<span class="literal">false</span>)  <span class="comment">//  滚动到可视范围底部</span></span><br></pre></td></tr></table></figure></p><p>对象</p><ul><li>behavior 可选<br>定义缓动动画， “auto”, “instant”, 或 “smooth” 之一。默认为 “auto”。</li><li>block 可选<br>“start”, “center”, “end”, 或 “nearest”之一。默认为 “start”。</li><li>inline 可选<br>“start”, “center”, “end”, 或 “nearest”之一。默认为 “nearest”。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画运动到可视范围中间</span></span><br><span class="line">element.scrollIntoView(&#123;<span class="attr">behavior</span>: <span class="string">"smooth"</span>, <span class="attr">block</span>: <span class="string">"center"</span>, <span class="attr">inline</span>: <span class="string">"center"</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>scrollIntoView(alignWithTop)：滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果alignWithTop为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。——-目前各浏览器均支持</li><li>scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视窗的可见范围内不可见的情况下，才滚动浏览器窗口或容器元素，最终让当前元素可见。如果当前元素在视窗中可见，这个方法不做任何处理。如果将可选参数alignCenter设置为true，则表示尽量将元素显示在视窗中部（垂直方向）——Safari、Chrome实现了这个方法</li><li>scrollByLines(lineCount)：将元素的内容滚动指定的行数的高度，lineCount的值可以为正值或是负值。—Safari、Chrome实现了这个方法</li><li>scrollByPages(pageCount)：将元素的内容滚动指定的页面的高度，具体高度由元素的高度决定。—Safari、Chrome实现了这个方法</li></ul><blockquote><p>scrollIntoView()和scrollIntoVIewIfNeeded()作用的是元素的窗口，而scrollByLines()、scrollByPages()影响元素自身</p></blockquote><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>由于这个属性还没有成为通用标准，所以使用前需要注意兼容性。</p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的一些知识点</title>
      <link href="/2019/06/27/vue%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/06/27/vue%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-config-productiontip-false"><a href="#vue-config-productiontip-false" class="headerlink" title="vue.config.productiontip = false"></a>vue.config.productiontip = false</h2><p>类型： boolean<br>默认值： true<br>用法：<br>设置为 false 以阻止 vue 在启动时生成生产提示。</p><h2 id="jquery-animate"><a href="#jquery-animate" class="headerlink" title="jquery animate"></a>jquery animate</h2><p>(selector).animate({styles},speed,easing,callback)<br>animate() 方法执行 CSS 属性集的自定义动画。<br>该方法通过 CSS 样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。<br>只有数字值可创建动画（比如 “margin:30px”）。字符串值无法创建动画（比如 “background-color:red”）。</p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echarts部分基础配置项</title>
      <link href="/2019/06/19/echarts%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
      <url>/2019/06/19/echarts%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图表标题"><a href="#图表标题" class="headerlink" title="图表标题"></a>图表标题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;</span><br><span class="line">    text: <span class="string">'click'</span>,</span><br><span class="line">    subtext: <span class="string">'click it'</span>,</span><br><span class="line">    left: <span class="string">'left'</span>,                 <span class="comment">// 水平安放位置，默认为左对齐，可选为：</span></span><br><span class="line">                                <span class="comment">// 'center' ¦ 'left' ¦ 'right'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（x坐标，单位px）</span></span><br><span class="line">    top: <span class="string">'top'</span>,                  <span class="comment">// 垂直安放位置，默认为全图顶端，可选为：</span></span><br><span class="line">                                <span class="comment">// 'top' ¦ 'bottom' ¦ 'center'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（y坐标，单位px）</span></span><br><span class="line">    <span class="comment">//textAlign: null          // 水平对齐方式，默认根据x设置自动调整</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>,</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,       <span class="comment">// 标题边框颜色</span></span><br><span class="line">    borderWidth: <span class="number">0</span>,            <span class="comment">// 标题边框线宽，单位px，默认为0（无边框）</span></span><br><span class="line">    padding: <span class="number">5</span>,                <span class="comment">// 标题内边距，单位px，默认各方向内边距为5，</span></span><br><span class="line">                                <span class="comment">// 接受数组分别设定上右下左边距，同css</span></span><br><span class="line">    itemGap: <span class="number">10</span>,               <span class="comment">// 主副标题纵向间隔，单位px，默认为10</span></span><br><span class="line">    textStyle: &#123;</span><br><span class="line">        fontSize: <span class="number">18</span>,</span><br><span class="line">        fontWeight: <span class="string">'bolder'</span>,</span><br><span class="line">        color: <span class="string">'#333'</span>          <span class="comment">// 主标题文字颜色</span></span><br><span class="line">    &#125;,</span><br><span class="line">    subtextStyle: &#123;</span><br><span class="line">        color: <span class="string">'#aaa'</span>          <span class="comment">// 副标题文字颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">    type: <span class="string">'plain'</span>,              <span class="comment">//'plain'：普通图例。缺省就是普通图例。</span></span><br><span class="line">                                <span class="comment">//'scroll'：可滚动翻页的图例。当图例数量较多时可以使用。</span></span><br><span class="line"></span><br><span class="line">    orient: <span class="string">'horizontal'</span>,      <span class="comment">// 布局方式，默认为水平布局，可选为：</span></span><br><span class="line">                                <span class="comment">// 'horizontal' ¦ 'vertical'</span></span><br><span class="line"></span><br><span class="line">    left: <span class="string">'center'</span>,               <span class="comment">// 水平安放位置，默认为全图居中，可选为：</span></span><br><span class="line">                                <span class="comment">// 'center' ¦ 'left' ¦ 'right'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（x坐标，单位px）</span></span><br><span class="line"></span><br><span class="line">    top: <span class="string">'top'</span>,                  <span class="comment">// 垂直安放位置，默认为全图顶端，可选为：</span></span><br><span class="line">                                <span class="comment">// 'top' ¦ 'bottom' ¦ 'center'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（y坐标，单位px）</span></span><br><span class="line">    data: [<span class="string">'bar'</span>, <span class="string">'bar2'</span>],      <span class="comment">//图例内容</span></span><br><span class="line">        <span class="comment">//legend.data[i].icon string  图例项的 icon。</span></span><br><span class="line">        <span class="comment">//ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none'</span></span><br><span class="line">        <span class="comment">//可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI。</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>,</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,       <span class="comment">// 图例边框颜色</span></span><br><span class="line">    borderWidth: <span class="number">0</span>,            <span class="comment">// 图例边框线宽，单位px，默认为0（无边框）</span></span><br><span class="line">    padding: <span class="number">5</span>,                <span class="comment">// 图例内边距，单位px，默认各方向内边距为5，</span></span><br><span class="line">                                <span class="comment">// 接受数组分别设定上右下左边距，同css</span></span><br><span class="line">    itemGap: <span class="number">10</span>,               <span class="comment">// 各个item之间的间隔，单位px，默认为10，</span></span><br><span class="line">                                <span class="comment">// 横向布局时为水平间隔，纵向布局时为纵向间隔</span></span><br><span class="line">    itemWidth: <span class="number">20</span>,             <span class="comment">// 图例图形宽度</span></span><br><span class="line">    itemHeight: <span class="number">14</span>,            <span class="comment">// 图例图形高度</span></span><br><span class="line">    textStyle: &#123;</span><br><span class="line">        color: <span class="string">'#333'</span>          <span class="comment">// 图例文字颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="visualMap"><a href="#visualMap" class="headerlink" title="visualMap"></a>visualMap</h1><blockquote><p>visualMap 是由 ECharts2 中的 dataRange 组件改名以及扩展而来。ECharts3里 option 中的 dataRange 配置项仍然被兼容，会自动转换成 visualMap 配置项。在option中推荐写 visualMap 而非 dataRange。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">visualMap: &#123;</span><br><span class="line">    type: <span class="string">'continuous'</span>,         </span><br><span class="line">    orient: <span class="string">'vertical'</span>,        <span class="comment">// 布局方式，默认为垂直布局，可选为：</span></span><br><span class="line">                                <span class="comment">// 'horizontal' ¦ 'vertical'</span></span><br><span class="line">    left: <span class="string">'left'</span>,                 <span class="comment">// 水平安放位置，默认为全图左对齐，可选为：</span></span><br><span class="line">                                <span class="comment">// 'center' ¦ 'left' ¦ 'right'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（x坐标，单位px）</span></span><br><span class="line">    top: <span class="string">'bottom'</span>,               <span class="comment">// 垂直安放位置，默认为全图底部，可选为：</span></span><br><span class="line">                                <span class="comment">// 'top' ¦ 'bottom' ¦ 'center'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（y坐标，单位px）</span></span><br><span class="line">    seriesIndex: <span class="number">0</span>,             <span class="comment">//指定取哪个系列的数据，即哪个系列的 series.data。默认取所有系列。</span></span><br><span class="line">    min: <span class="string">'0'</span>,                   <span class="comment">//指定最小值</span></span><br><span class="line">    max: <span class="string">'100'</span>,                 <span class="comment">//指定最大值</span></span><br><span class="line">    calculable: <span class="literal">true</span>            <span class="comment">//是否显示手柄</span></span><br><span class="line">    realtime: <span class="literal">true</span>              <span class="comment">//拖拽时是否实时更新</span></span><br><span class="line">    text: [<span class="string">'High'</span>, <span class="string">'Low'</span>],      <span class="comment">//两端的文本,默认为数值文本</span></span><br><span class="line">    inRange: &#123;</span><br><span class="line">        color: [<span class="string">'#121122'</span>, <span class="string">'rgba(3,4,5,0.4)'</span>, <span class="string">'red'</span>],</span><br><span class="line">        symbolSize: [<span class="number">60</span>, <span class="number">200</span>]</span><br><span class="line">    &#125;,                          <span class="comment">//定义 在选中范围中 的视觉元素</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>,</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,       <span class="comment">// 值域边框颜色</span></span><br><span class="line">    borderWidth: <span class="number">0</span>,            <span class="comment">// 值域边框线宽，单位px，默认为0（无边框）</span></span><br><span class="line">    padding: <span class="number">5</span>,                <span class="comment">// 值域内边距，单位px，默认各方向内边距为5，</span></span><br><span class="line">                                <span class="comment">// 接受数组分别设定上右下左边距，同css</span></span><br><span class="line">    itemGap: <span class="number">10</span>,               <span class="comment">// 各个item之间的间隔，单位px，默认为10，</span></span><br><span class="line">                                <span class="comment">// 横向布局时为水平间隔，纵向布局时为纵向间隔</span></span><br><span class="line">    itemWidth: <span class="number">20</span>,             <span class="comment">// 值域图形宽度，线性渐变水平布局宽度为该值 * 10</span></span><br><span class="line">    itemHeight: <span class="number">14</span>,            <span class="comment">// 值域图形高度，线性渐变垂直布局高度为该值 * 10</span></span><br><span class="line">    color:[<span class="string">'#1e90ff'</span>,<span class="string">'#f0ffff'</span>],<span class="comment">//颜色 </span></span><br><span class="line">    textStyle: &#123;</span><br><span class="line">        color: <span class="string">'#333'</span>          <span class="comment">// 值域文字颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visualMap: &#123;</span><br><span class="line">    type: <span class="string">'piecewise'</span>,         </span><br><span class="line">    orient: <span class="string">'vertical'</span>,        <span class="comment">// 布局方式，默认为垂直布局，可选为：</span></span><br><span class="line">                                <span class="comment">// 'horizontal' ¦ 'vertical'</span></span><br><span class="line">    left: <span class="string">'left'</span>,                 <span class="comment">// 水平安放位置，默认为全图左对齐，可选为：</span></span><br><span class="line">                                <span class="comment">// 'center' ¦ 'left' ¦ 'right'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（x坐标，单位px）</span></span><br><span class="line">    top: <span class="string">'bottom'</span>,               <span class="comment">// 垂直安放位置，默认为全图底部，可选为：</span></span><br><span class="line">                                <span class="comment">// 'top' ¦ 'bottom' ¦ 'center'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（y坐标，单位px）</span></span><br><span class="line">    seriesIndex: <span class="number">0</span>,             <span class="comment">//指定取哪个系列的数据，即哪个系列的 series.data。默认取所有系列。</span></span><br><span class="line">    categories: [<span class="string">'优'</span>,<span class="string">'良'</span>],     <span class="comment">//用于表示离散型数据（或可以称为类别型数据、枚举型数据）的全集。</span></span><br><span class="line">    pieces:[</span><br><span class="line">        &#123;<span class="attr">min</span>: <span class="number">1500</span>&#125;, <span class="comment">// 不指定 max，表示 max 为无限大（Infinity）。</span></span><br><span class="line">        &#123;<span class="attr">min</span>: <span class="number">900</span>, <span class="attr">max</span>: <span class="number">1500</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">min</span>: <span class="number">310</span>, <span class="attr">max</span>: <span class="number">1000</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">min</span>: <span class="number">200</span>, <span class="attr">max</span>: <span class="number">300</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">min</span>: <span class="number">10</span>, <span class="attr">max</span>: <span class="number">200</span>, <span class="attr">label</span>: <span class="string">'10 到 200（自定义label）'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="number">123</span>, <span class="attr">label</span>: <span class="string">'123（自定义特殊颜色）'</span>, <span class="attr">color</span>: <span class="string">'grey'</span>&#125;, <span class="comment">// 表示 value 等于 123 的情况。</span></span><br><span class="line">        &#123;<span class="attr">max</span>: <span class="number">5</span>&#125;     <span class="comment">// 不指定 min，表示 min 为无限大（-Infinity）。</span></span><br><span class="line">    ],                          <span class="comment">//type为piecewise时用于设置每一段范围和样式</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>,</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,       <span class="comment">// 值域边框颜色</span></span><br><span class="line">    borderWidth: <span class="number">0</span>,            <span class="comment">// 值域边框线宽，单位px，默认为0（无边框）</span></span><br><span class="line">    padding: <span class="number">5</span>,                <span class="comment">// 值域内边距，单位px，默认各方向内边距为5，</span></span><br><span class="line">                                <span class="comment">// 接受数组分别设定上右下左边距，同css</span></span><br><span class="line">    itemGap: <span class="number">10</span>,               <span class="comment">// 各个item之间的间隔，单位px，默认为10，</span></span><br><span class="line">                                <span class="comment">// 横向布局时为水平间隔，纵向布局时为纵向间隔</span></span><br><span class="line">    itemWidth: <span class="number">20</span>,             <span class="comment">// 值域图形宽度，线性渐变水平布局宽度为该值 * 10</span></span><br><span class="line">    itemHeight: <span class="number">14</span>,            <span class="comment">// 值域图形高度，线性渐变垂直布局高度为该值 * 10</span></span><br><span class="line">    splitNumber: <span class="number">5</span>,            <span class="comment">// 对于连续型数据，默认为5，为0时为线性渐变,</span></span><br><span class="line">                                <span class="comment">//如果设置了 pieces 或者 categories，则 splitNumber 无效</span></span><br><span class="line">    color:[<span class="string">'#1e90ff'</span>,<span class="string">'#f0ffff'</span>],<span class="comment">//颜色 </span></span><br><span class="line">    <span class="comment">//text:['高','低'],         // 文本，默认为数值文本</span></span><br><span class="line">    textStyle: &#123;</span><br><span class="line">        color: <span class="string">'#333'</span>          <span class="comment">// 值域文字颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">toolbox: &#123;</span><br><span class="line">    orient: <span class="string">'horizontal'</span>,      <span class="comment">// 布局方式，默认为水平布局，可选为：</span></span><br><span class="line">                                <span class="comment">// 'horizontal' ¦ 'vertical'</span></span><br><span class="line">    left: <span class="string">'right'</span>,                <span class="comment">// 水平安放位置，默认为全图右对齐，可选为：</span></span><br><span class="line">                                <span class="comment">// 'center' ¦ 'left' ¦ 'right'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（x坐标，单位px）</span></span><br><span class="line">    top: <span class="string">'top'</span>,                  <span class="comment">// 垂直安放位置，默认为全图顶端，可选为：</span></span><br><span class="line">                                <span class="comment">// 'top' ¦ 'bottom' ¦ 'center'</span></span><br><span class="line">                                <span class="comment">// ¦ &#123;number&#125;（y坐标，单位px）</span></span><br><span class="line">    color : [<span class="string">'#1e90ff'</span>,<span class="string">'#22bb22'</span>,<span class="string">'#4b0082'</span>,<span class="string">'#d2691e'</span>],</span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>, <span class="comment">// 工具箱背景颜色</span></span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,       <span class="comment">// 工具箱边框颜色</span></span><br><span class="line">    borderWidth: <span class="number">0</span>,            <span class="comment">// 工具箱边框线宽，单位px，默认为0（无边框）</span></span><br><span class="line">    padding: <span class="number">5</span>,                <span class="comment">// 工具箱内边距，单位px，默认各方向内边距为5，</span></span><br><span class="line">                                <span class="comment">// 接受数组分别设定上右下左边距，同css</span></span><br><span class="line">    itemGap: <span class="number">10</span>,               <span class="comment">// 各个item之间的间隔，单位px，默认为10，</span></span><br><span class="line">                                <span class="comment">// 横向布局时为水平间隔，纵向布局时为纵向间隔</span></span><br><span class="line">    itemSize: <span class="number">16</span>,              <span class="comment">// 工具箱图形宽度</span></span><br><span class="line">    featureImageIcon : &#123;&#125;,     <span class="comment">// 自定义图片icon</span></span><br><span class="line">    showTitle: <span class="literal">true</span>,            <span class="comment">//是否在鼠标 hover 的时候显示每个工具 icon 的标题</span></span><br><span class="line">    feature:&#123;                   <span class="comment">//各工具配置项</span></span><br><span class="line">        dataZoom: &#123;</span><br><span class="line">            yAxisIndex: <span class="string">'none'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        dataView: &#123;<span class="attr">readOnly</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">        magicType: &#123;<span class="attr">type</span>: [<span class="string">'line'</span>, <span class="string">'bar'</span>]&#125;,</span><br><span class="line">        restore: &#123;&#125;,</span><br><span class="line">        saveAsImage: &#123;&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h1><p>提示框组件可以设置在多种地方：</p><ul><li>可以设置在全局，即 tooltip</li><li>可以设置在坐标系中，即 grid.tooltip、polar.tooltip、single.tooltip</li><li>可以设置在系列中，即 series.tooltip</li><li>可以设置在系列的每个数据项中，即 series.data.tooltip</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">tooltip: &#123;</span><br><span class="line">    trigger: <span class="string">'item'</span>,           <span class="comment">// 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'</span></span><br><span class="line">                                <span class="comment">//'item'数据项图形触发 'axis'坐标轴触发</span></span><br><span class="line">    showDelay: <span class="number">20</span>,             <span class="comment">// 显示延迟，添加显示延迟可以避免频繁切换，单位ms</span></span><br><span class="line">    hideDelay: <span class="number">100</span>,            <span class="comment">// 隐藏延迟，单位ms</span></span><br><span class="line">    transitionDuration : <span class="number">0.4</span>,  <span class="comment">// 动画变换时间，单位s</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0.7)'</span>,     <span class="comment">// 提示背景颜色，默认为透明度为0.7的黑色</span></span><br><span class="line">    borderColor: <span class="string">'#333'</span>,       <span class="comment">// 提示边框颜色</span></span><br><span class="line">    borderRadius: <span class="number">4</span>,           <span class="comment">// 提示边框圆角，单位px，默认为4</span></span><br><span class="line">    borderWidth: <span class="number">0</span>,            <span class="comment">// 提示边框线宽，单位px，默认为0（无边框）</span></span><br><span class="line">    padding: <span class="number">5</span>,                <span class="comment">// 提示内边距，单位px，默认各方向内边距为5，</span></span><br><span class="line">                                <span class="comment">// 接受数组分别设定上右下左边距，同css</span></span><br><span class="line">    axisPointer : &#123;            <span class="comment">// 坐标轴指示器，坐标轴触发有效</span></span><br><span class="line">        type : <span class="string">'line'</span>,         <span class="comment">// 默认为直线，可选为：'line' | 'shadow'</span></span><br><span class="line">        lineStyle : &#123;          <span class="comment">// 直线指示器样式设置</span></span><br><span class="line">            color: <span class="string">'#48b'</span>,</span><br><span class="line">            width: <span class="number">2</span>,</span><br><span class="line">            type: <span class="string">'solid'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        shadowStyle : &#123;                       <span class="comment">// 阴影指示器样式设置</span></span><br><span class="line">            width: <span class="string">'auto'</span>,                   <span class="comment">// 阴影大小</span></span><br><span class="line">            color: <span class="string">'rgba(150,150,150,0.3)'</span>  <span class="comment">// 阴影颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    textStyle: &#123;</span><br><span class="line">        color: <span class="string">'#fff'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区域缩放控制器"><a href="#区域缩放控制器" class="headerlink" title="区域缩放控制器"></a>区域缩放控制器</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dataZoom: &#123;</span><br><span class="line">    type: <span class="string">'inside'</span>,             <span class="comment">//'inside'或'slider'</span></span><br><span class="line">    orient: <span class="string">'horizontal'</span>,      <span class="comment">// 布局方式，默认为水平布局，可选为：</span></span><br><span class="line">                                <span class="comment">// 'horizontal' ¦ 'vertical'</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>,       <span class="comment">// 背景颜色</span></span><br><span class="line">    dataBackgroundColor: <span class="string">'#eee'</span>,            <span class="comment">// 数据背景颜色</span></span><br><span class="line">    fillerColor: <span class="string">'rgba(144,197,237,0.2)'</span>,   <span class="comment">// 填充颜色</span></span><br><span class="line">    handleColor: <span class="string">'rgba(70,130,180,0.8)'</span>     <span class="comment">// 手柄颜色</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grid:&#123;</span><br><span class="line">    x: <span class="number">80</span>,</span><br><span class="line">    y: <span class="number">60</span>,</span><br><span class="line">    x2: <span class="number">80</span>,</span><br><span class="line">    y2: <span class="number">60</span>,</span><br><span class="line">    <span class="comment">//x 为直角坐标系内绘图网格左上角横坐标，数值单位px，支持百分比（字符串），如'50%'(显示区域横向中心)</span></span><br><span class="line">    <span class="comment">//y 为左上纵坐标，x2为右下横坐标，y2为右下纵坐标。</span></span><br><span class="line">    id: <span class="number">0</span>,                            <span class="comment">//组件ID</span></span><br><span class="line">    show: <span class="literal">false</span>,                       <span class="comment">//是否显示直角坐标系网格</span></span><br><span class="line">    left: <span class="number">10</span>%,                          <span class="comment">//grid组件距离容器左侧的距离，默认10%</span></span><br><span class="line">    <span class="comment">//left 的值可以是像 20 这样的具体像素值，可以是像 '20%' 这样相对于容器高宽的百分比，也可以是 'left', 'center', 'right'。</span></span><br><span class="line">    top: <span class="number">60</span>                             <span class="comment">//默认60</span></span><br><span class="line">    backgroundColor: <span class="string">'rgba(0,0,0,0)'</span>,</span><br><span class="line">    borderWidth: <span class="number">1</span>,</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="xAxis"><a href="#xAxis" class="headerlink" title="xAxis"></a>xAxis</h1><p>直角坐标系 grid 中的 x 轴，一般情况下单个 grid 组件最多只能放上下两个 x 轴，多于两个 x 轴需要通过配置 offset 属性防止同个位置多个 x 轴的重叠。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">xAxis:&#123;</span><br><span class="line">    show:<span class="literal">true</span>,                <span class="comment">//是否显示 x 轴</span></span><br><span class="line">    gridIndex:<span class="number">0</span>,              <span class="comment">//x 轴所在的 grid 的索引，默认位于第一个 grid</span></span><br><span class="line">    position:<span class="string">"bottom"</span>,       <span class="comment">//x 轴的位置。"top"，"bottom"，默认 grid 中的第一个 x 轴在 grid 的下方（'bottom'），第二个 x 轴视第一个 x 轴的位置放在另一侧</span></span><br><span class="line">    offset:<span class="number">0</span>,                 <span class="comment">//X 轴相对于默认位置的偏移，在相同的 position 上有多个 X 轴的时候有用</span></span><br><span class="line">    type:<span class="string">"category"</span>,         <span class="comment">//坐标轴类型。'value' 数值轴，适用于连续数据。'category' 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。</span></span><br><span class="line">                                <span class="comment">// 'time' 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。'log' 对数轴。适用于对数数据</span></span><br><span class="line">    name:<span class="string">'时间'</span>,               <span class="comment">//坐标轴名称</span></span><br><span class="line">    nameLocation:<span class="string">"end"</span>,       <span class="comment">//坐标轴名称显示位置。可选：'start','middle','end'</span></span><br><span class="line">    nameTextStyle:mytextStyle,  <span class="comment">//坐标轴名称的文字样式</span></span><br><span class="line">    nameGap:<span class="number">15</span>,                  <span class="comment">//坐标轴名称与轴线之间的距离</span></span><br><span class="line">    nameRotate:<span class="number">0</span>,                <span class="comment">//坐标轴名字旋转，角度值</span></span><br><span class="line">    inverse:<span class="literal">false</span>,              <span class="comment">//是否是反向坐标轴</span></span><br><span class="line">    boundaryGap:<span class="literal">true</span>,           <span class="comment">//类目轴中 boundaryGap 可以配置为 true 和 false。非类目轴，包括时间，数值，对数轴，boundaryGap是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置 min 和 max 后无效['20%', '20%']</span></span><br><span class="line">    min:<span class="literal">null</span>,                    <span class="comment">//坐标轴刻度最小值。可以设置成特殊值 'dataMin'，此时取数据在该轴上的最小值作为最小刻度。不设置时会自动计算最小值保证坐标轴刻度的均匀分布。在类目轴中，也可以设置为类目的序数</span></span><br><span class="line">    max:<span class="literal">null</span>,                   <span class="comment">//坐标轴刻度最大值。可以设置成特殊值 'dataMax'，此时取数据在该轴上的最大值作为最大刻度。不设置时会自动计算最大值保证坐标轴刻度的均匀分布。在类目轴中，也可以设置为类目的序数</span></span><br><span class="line">    scale:<span class="literal">false</span>,                <span class="comment">//只在数值轴中（type: 'value'）有效。是否是脱离 0 值比例。设置成 true 后坐标刻度不会强制包含零刻度。在双数值轴的散点图中比较有用。在设置 min 和 max 之后该配置项无效。</span></span><br><span class="line">    splitNumber:<span class="number">5</span>,             <span class="comment">//坐标轴的分割段数，需要注意的是这个分割段数只是个预估值，最后实际显示的段数会在这个基础上根据分割后坐标轴刻度显示的易读程度作调整</span></span><br><span class="line">    minInterval:<span class="number">0</span>,             <span class="comment">//自动计算的坐标轴最小间隔大小,例如可以设置成1保证坐标轴分割刻度显示成整数。只在数值轴中（type: 'value'）有效。</span></span><br><span class="line">    logBase:<span class="number">10</span>,                 <span class="comment">//对数轴的底数，只在对数轴中（type: 'log'）有效</span></span><br><span class="line">    silent:<span class="literal">false</span>,              <span class="comment">//坐标轴是否是静态无法交互</span></span><br><span class="line">    triggerEvent:<span class="literal">false</span>,       <span class="comment">//坐标轴的标签是否响应和触发鼠标事件</span></span><br><span class="line">    axisLine:&#123;                 <span class="comment">//坐标 轴线</span></span><br><span class="line">        show:<span class="literal">true</span>,             <span class="comment">//是否显示坐标轴轴线</span></span><br><span class="line">        onZero:<span class="literal">true</span>,           <span class="comment">//X 轴或者 Y 轴的轴线是否在另一个轴的 0 刻度上，只有在另一个轴为数值轴且包含 0 刻度时有效</span></span><br><span class="line">        lineStyle:mylineStyle</span><br><span class="line">    &#125;,</span><br><span class="line">    axisTick :&#123;                 <span class="comment">//坐标轴刻度相关设置</span></span><br><span class="line">        show:<span class="literal">true</span>,              <span class="comment">//是否显示坐标轴刻度。</span></span><br><span class="line">        alignWithLabel:<span class="literal">false</span>,  <span class="comment">//类目轴中在 boundaryGap 为 true 的时候有效，可以保证刻度线和标签对齐</span></span><br><span class="line">        interval:auto,          <span class="comment">//坐标轴刻度的显示间隔，在类目轴中有效。默认会采用标签不重叠的策略间隔显示标签。可以设置成 0 强制显示所有标签。如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推</span></span><br><span class="line">        inside:<span class="literal">false</span>,           <span class="comment">//坐标轴刻度是否朝内，默认朝外。</span></span><br><span class="line">        length:<span class="number">5</span>,                <span class="comment">//坐标轴刻度的长度。</span></span><br><span class="line">        lineStyle:mylineStyle</span><br><span class="line">    &#125;,</span><br><span class="line">    axisLabel:&#123;                 <span class="comment">//坐标轴刻度标签的相关设置</span></span><br><span class="line">        show:<span class="literal">true</span>,              <span class="comment">//是否显示</span></span><br><span class="line">        interval:<span class="string">"auto"</span>,        <span class="comment">//坐标轴刻度标签的显示间隔，在类目轴中有效。默认会采用标签不重叠的策略间隔显示标签。可以设置成 0 强制显示所有标签。如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推</span></span><br><span class="line">        inside:<span class="literal">false</span>,           <span class="comment">//刻度标签是否朝内，默认朝外</span></span><br><span class="line">        rotate:<span class="number">0</span>,               <span class="comment">//刻度标签旋转的角度，在类目轴的类目标签显示不下的时候可以通过旋转防止标签之间重叠。旋转的角度从 -90 度到 90 度</span></span><br><span class="line">        margin:<span class="number">8</span>,               <span class="comment">//刻度标签与轴线之间的距离</span></span><br><span class="line">        formatter: <span class="function"><span class="keyword">function</span> (<span class="params">value, index</span>) </span>&#123;            <span class="comment">//使用函数模板，函数参数分别为刻度数值（类目），刻度的索引</span></span><br><span class="line">            <span class="keyword">return</span> value+<span class="string">"kg"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        showMinLabel:<span class="literal">null</span>,      <span class="comment">//是否显示最小 tick 的 label。可取值 true, false, null。默认自动判定（即如果标签重叠，不会显示最小 tick 的 label）</span></span><br><span class="line">        showMaxLabel:<span class="literal">null</span>,      <span class="comment">//是否显示最大 tick 的 label。可取值 true, false, null。默认自动判定（即如果标签重叠，不会显示最大 tick 的 label）</span></span><br><span class="line">        textStyle:mytextStyle</span><br><span class="line">    &#125;,</span><br><span class="line">    splitLine:&#123;                 <span class="comment">//坐标轴在 grid 区域中的分隔线。</span></span><br><span class="line">        show:<span class="literal">true</span>,              <span class="comment">//是否显示分隔线。默认数值轴显示，类目轴不显示。</span></span><br><span class="line">        interval:<span class="string">"auto"</span>,        <span class="comment">//坐标轴分隔线的显示间隔，在类目轴中有效。默认会采用标签不重叠的策略间隔显示标签。可以设置成 0 强制显示所有标签。如果设置为 1，表示『隔一个标签显示一个标签』，可以用数值表示间隔的数据，也可以通过回调函数控制。回调函数格式如下：</span></span><br><span class="line">        lineStyle:mylineStyle</span><br><span class="line">    &#125;,</span><br><span class="line">    splitArea:&#123;                 <span class="comment">//坐标轴在 grid 区域中的分隔区域，默认不显示。</span></span><br><span class="line">        interval:<span class="string">"auto"</span>,</span><br><span class="line">        show:<span class="literal">false</span>,             <span class="comment">//是否显示分隔区域</span></span><br><span class="line">        areaStyle:myareaStyle</span><br><span class="line">    &#125;,</span><br><span class="line">    data : [<span class="string">'周一'</span>, <span class="string">'周二'</span>, <span class="string">'周三'</span>, <span class="string">'周四'</span>, <span class="string">'周五'</span>, <span class="string">'周六'</span>, <span class="string">'周日'</span>],             <span class="comment">//类目数据，在类目轴（type: 'category'）中有效。</span></span><br><span class="line">    zlevel:<span class="number">0</span>,                   <span class="comment">//X 轴所有图形的 zlevel 值。</span></span><br><span class="line">    z:<span class="number">0</span>,                        <span class="comment">//X 轴组件的所有图形的z值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="yAxis"><a href="#yAxis" class="headerlink" title="yAxis"></a>yAxis</h1><p>类似于xAxis</p><h1 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h1><p>地理坐标系组件用于地图的绘制，支持在地理坐标系上绘制散点图，线集。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">geo: &#123;</span><br><span class="line">    map: <span class="string">'china'</span>,</span><br><span class="line">    silent: <span class="literal">false</span>,<span class="comment">//图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。</span></span><br><span class="line">    roam: <span class="literal">false</span>,<span class="comment">//是否开启鼠标缩放和平移漫游。默认不开启。</span></span><br><span class="line">    <span class="comment">//如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启</span></span><br><span class="line">    zoom: <span class="number">1</span>, <span class="comment">// 地图初始大小</span></span><br><span class="line">    center: [<span class="number">116.366794</span>, <span class="number">40.400309</span>], <span class="comment">// 初始中心位置</span></span><br><span class="line">    label: &#123;</span><br><span class="line">        color:<span class="string">"#fff"</span>,</span><br><span class="line">        emphasis: &#123;</span><br><span class="line">            show: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    itemStyle: &#123;</span><br><span class="line">        normal: &#123;</span><br><span class="line">            areaColor: <span class="string">'#323c48'</span>,</span><br><span class="line">            borderColor: <span class="string">'#111'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        emphasis: &#123;</span><br><span class="line">            areaColor: <span class="string">'#2a333d'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue初始化过程</title>
      <link href="/2019/06/18/Vue%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/06/18/Vue%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍Vue实例beforeMount前的初始化内容</p></blockquote><h2 id="Vue生命周期图示"><a href="#Vue生命周期图示" class="headerlink" title="Vue生命周期图示"></a>Vue生命周期图示</h2><p><img src="/img/vueLifecycle.png" alt></p><h2 id="init-Events-amp-Lifecycle"><a href="#init-Events-amp-Lifecycle" class="headerlink" title="init Events &amp; Lifecycle"></a>init Events &amp; Lifecycle</h2><ul><li>进行vue生命周期变量的初始化，如:$parent、$root、$children、$ref等(initLifecycle)</li><li>事件监听的初始化(initEvents)</li><li>编译render初始化(initRender)</li></ul><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p>进行beforeCreate生命钩子回调</p><h2 id="init-injections-amp-reactivity"><a href="#init-injections-amp-reactivity" class="headerlink" title="init injections &amp; reactivity"></a>init injections &amp; reactivity</h2><ul><li>绑定inject(initInjections)</li><li>state状态初始化(initState)<ul><li>初始化props</li><li>初始化方法methods</li><li>初始化data</li><li>初始化computed</li><li>初始化watch</li></ul></li><li>绑定provide(initProvide)</li></ul><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p>进行created生命钩子回调</p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue处理边界情况</title>
      <link href="/2019/06/18/Vue%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5/"/>
      <url>/2019/06/18/Vue%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素 &amp; 组件"></a>访问元素 &amp; 组件</h1><p>在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的。</p><h2 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h2><p>在每个 new Vue 实例的子组件中，其根实例可以通过 $root 属性进行访问。例如，在这个根实例中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    baz: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.baz()</span><br></pre></td></tr></table></figure></p><p>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 Vuex 来管理应用的状态。</p><h2 id="访问父级组件实例"><a href="#访问父级组件实例" class="headerlink" title="访问父级组件实例"></a>访问父级组件实例</h2><p>和 $root 类似，$parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。</p><p>在绝大多数情况下，触达父级组件会使得你的应用更难调试和理解，尤其是当你变更了父级组件的数据的时候。当我们稍后回看那个组件的时候，很难找出那个变更是从哪里发起的。</p><p>另外在一些可能适当的时候，你需要特别地共享一些组件库。举个例子，在和 JavaScript API 进行交互而不渲染 HTML 的抽象组件内，诸如这些假设性的 Google 地图组件一样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个 <google-map> 组件可以定义一个 map 属性，所有的子组件都需要访问它。在这种情况下 <google-map-markers> 可能想要通过类似 this.$parent.getMap 的方式访问那个地图，以便为其添加一组标记。你可以在这里查阅这种模式。</google-map-markers></google-map></p><p>请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下我们添加一个新的 <google-map-region> 组件，当 <google-map-markers> 在其内部出现的时候，只会渲染那个区域内的标记：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">"cityBoundaries"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure></google-map-markers></google-map-region></p><p>那么在 <google-map-markers> 内部你可能发现自己需要一些类似这样的 hack：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">this</span>.$parent.map || <span class="keyword">this</span>.$parent.$parent.map</span><br></pre></td></tr></table></figure></google-map-markers></p><p>很快它就会失控。这也是我们针对需要向任意更深层级的组件提供上下文信息时推荐依赖注入的原因。</p><h2 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a>访问子组件实例或子元素</h2><p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 特性为这个子组件赋予一个 ID 引用。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">"usernameInput"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在在你已经定义了这个 ref 的组件里，你可以使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput</span><br></pre></td></tr></table></figure></p><p>来访问这个 <base-input> 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 <base-input> 组件也可以使用一个类似的 ref 提供对内部这个指定元素的访问，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"input"</span>&gt;</span></span><br></pre></td></tr></table></figure></base-input></base-input></p><p>甚至可以通过其父级组件定义方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 用来从父级组件聚焦输入框</span></span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就允许父级组件通过下面的代码聚焦 <base-input> 里的输入框：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput.focus()</span><br></pre></td></tr></table></figure></base-input></p><p>当 ref 和 v-for 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。</p><p>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>在此之前，在我们描述访问父级组件实例的时候，展示过一个类似这样的例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">"cityBoundaries"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在这个组件里，所有 <google-map> 的后代都需要访问一个 getMap 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 $parent 属性无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。</google-map></p><p>provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></google-map></p><p>然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure></p><p>相比 $parent 来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 <google-map> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样。</google-map></p><p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p><ul><li>祖先组件不需要知道哪些后代组件使用它提供的属性</li><li>后代组件不需要知道被注入的属性来自哪里</li></ul><p>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html" target="_blank" rel="noopener">Vue处理边界情况</a></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue使用key属性管理可复用元素</title>
      <link href="/2019/06/18/Vue%E4%BD%BF%E7%94%A8key%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2019/06/18/Vue%E4%BD%BF%E7%94%A8key%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>最近在使用Vue开发项目时，遇到了如下的问题：<br>在使用v-if进行状态切换时，Vue会复用两部分中相同的组件，导致该组件的created和自定义指令(bind形式)等不执行，一些状态不会进行刷新。</p></blockquote><p>代码如下:<br>Test.vue文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fz-form</span> <span class="attr">ref</span>=<span class="string">"data"</span> <span class="attr">:model</span>=<span class="string">"addData"</span> <span class="attr">label-width</span>=<span class="string">"120px"</span> <span class="attr">v-if</span>=<span class="string">"step == 1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fz-form-item</span> <span class="attr">label</span>=<span class="string">"手机号："</span> <span class="attr">prop</span>=<span class="string">"phone"</span> <span class="attr">validate</span>=<span class="string">"required,Phone"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"用户名/手机号"</span> <span class="attr">v-model</span>=<span class="string">"addData.phone"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fz-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fz-form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fz-form</span> <span class="attr">ref</span>=<span class="string">"data1"</span> <span class="attr">:model</span>=<span class="string">"addData"</span> <span class="attr">label-width</span>=<span class="string">"120px"</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fz-form-item</span>  <span class="attr">label</span>=<span class="string">"新密码："</span> <span class="attr">prop</span>=<span class="string">"password"</span> <span class="attr">validate</span>=<span class="string">"required,password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addData.password"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fz-form-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fz-form-item</span> <span class="attr">label</span>=<span class="string">"确认新密码："</span> <span class="attr">prop</span>=<span class="string">"endpassword"</span> <span class="attr">validate</span>=<span class="string">"required,password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">"addData.endpassword"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">fz-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fz-form</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>FormItem.vue文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    directives: &#123;</span><br><span class="line">        validate: &#123;</span><br><span class="line">            bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//bind中定义了el-form的验证规则</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码的执行效果如下:<br><img src="/img/vuekeymg.png" alt><br>当从第一个表单切换到第二个表单时，vue会复用组件中的fz-form-item，而不会重新渲染该元素，这会使得该组件中的部分方法不执行，导致自定义的验证方法出现异常。</p><p>解决方法：<br>这里可以使用key对组件进行管理，可以在必要的地方避免组件复用，使得组件进行重新渲染。</p><h2 id="用key管理可复用的元素"><a href="#用key管理可复用的元素" class="headerlink" title="用key管理可复用的元素"></a>用key管理可复用的元素</h2><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</p><p>同时 Vue 提供了一种方式来满足不复用已有元素的业务场景，此时只需要添加一个具有唯一值key属性。</p><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。</p><p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/78727cf3ef14" target="_blank" rel="noopener">Vue 用 key 属性管理可复用的元素</a></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端页面通过拖拽选择文件</title>
      <link href="/2019/06/17/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E9%80%9A%E8%BF%87%E6%8B%96%E6%8B%BD%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6/"/>
      <url>/2019/06/17/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E9%80%9A%E8%BF%87%E6%8B%96%E6%8B%BD%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过处理拖拽事件可以让用户通过拖拽的方式将文件拖拽到应用中</p></blockquote><p>第一步是创建一个drop区域。虽然你网页内容的哪部分接受拖放取决于你的应用设计，但是使一个元素接收drop事件是很容易的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dropbox;</span><br><span class="line"></span><br><span class="line">dropbox = <span class="built_in">document</span>.getElementById(<span class="string">"dropbox"</span>);</span><br><span class="line">dropbox.addEventListener(<span class="string">"dragenter"</span>, dragenter, <span class="literal">false</span>);</span><br><span class="line">dropbox.addEventListener(<span class="string">"dragover"</span>, dragover, <span class="literal">false</span>);</span><br><span class="line">dropbox.addEventListener(<span class="string">"drop"</span>, drop, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将ID为dropbox的元素变为了我们的drop区域。这个只需要给元素添加dragenter, dragover, 和drop 事件监听器就完成。<br>我们其实并不需要对dragenter and dragover 事件进行处理，所以这些函数都很简单。他们只需要包括禁止事件传播和阻止默认事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragenter</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragover</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分在drop()这个函数中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dt = e.dataTransfer;</span><br><span class="line">  <span class="keyword">var</span> files = dt.files;</span><br><span class="line"></span><br><span class="line">  handleFiles(files);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们从事件中获取到了dataTransfer 这个域，然后从中得到文件列表，再将他们传递给handleFiles()函数。从这一点开始，处理文件的方法和用input元素或者用拖拽是一样的了。</p><h3 id="dataTransfer"><a href="#dataTransfer" class="headerlink" title="dataTransfer"></a>dataTransfer</h3><p>在进行拖放操作时，DataTransfer 对象用来保存，通过拖放动作，拖动到浏览器的数据。它可以保存一项或多项数据、一种或者多种数据类型。</p><p>拖放触发的拖放事件有一个dataTransfer属性，该属性值是一个DataTransfer对象，该对象包含如下属性和方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataTransfer.dropEffect：设置或返回拖放目标上允许发生的拖放行为。如果此设置的拖放行为不在effectAllowed属性设置的多种拖放行为之内，拖放操作将会失败。该属性值只允许none、copy、link、move值之一。</span><br><span class="line"></span><br><span class="line">dataTransfer.effectAllowed：设置或返回被拖动元素允许发生的拖动行为。该属性值可设置为none、copy、copyLink、copyMove、link、linkMove、move、all、uninitialized。</span><br><span class="line"></span><br><span class="line">dataTransfer.files：包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。此属性访问指定的FileList 中无效的索引将返回未定义（undefined）。</span><br><span class="line"></span><br><span class="line">dataTransfer.types：types节保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。如果没有添加数据将返回一个空列表。</span><br><span class="line"></span><br><span class="line">dataTransfer.setDragImage(element x,y)：设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向的距离；y设置图标与鼠标在垂直方向的距离。</span><br><span class="line"></span><br><span class="line">dataTransfer.addElement(element)：添加自定义图标。</span><br><span class="line"></span><br><span class="line">dataTransfer.getData(format)：获取DataTransfer对象中设置format格式的数据。其中format代表数据格式，data代表数据。</span><br><span class="line"></span><br><span class="line">dataTransfer.setData(type,data): 为一个给定的类型设置数据。如果该数据类型不存在，它将添加到的末尾，这样类型列表中的最后一个项目将是新的格式。如果已经存在的数据类型，替换相同的位置的现有数据。</span><br><span class="line"></span><br><span class="line">dataTransfer.clearData([format])：清除DataTransfer对象中format格式的数据，如果省略format格式，则意味着清除DataTransfer对象中的全部数据。</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="noopener">MDN DataTransfer</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications" target="_blank" rel="noopener">Using files from web applications</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue父组件和子组件间的方法调用</title>
      <link href="/2019/06/17/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>/2019/06/17/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue父组件调用子组件方法"><a href="#Vue父组件调用子组件方法" class="headerlink" title="Vue父组件调用子组件方法"></a>Vue父组件调用子组件方法</h1><p>vue中如果父组件想调用子组件的方法，可以通过设置子组件的ref属性，然后通过this.$refs.ref.method调用，例如：</p><p>父组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"fatherMethod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/child.vue'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$refs.child.childMethods();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>子组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">'子组件'</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethods() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在父组件中， this.$refs.child 返回的是一个vue实例，可以直接调用这个实例的方法</p><h1 id="子组件调用父组件方法"><a href="#子组件调用父组件方法" class="headerlink" title="子组件调用父组件方法"></a>子组件调用父组件方法</h1><p>Vue中子组件调用父组件的方法，这里有三种方法提供参考</p><h2 id="this-parent-event"><a href="#this-parent-event" class="headerlink" title="this.$parent.event"></a>this.$parent.event</h2><p>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法<br>父组件:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/child'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'父组件'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>子组件:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$parent.fatherMethod();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="this-emit-…"><a href="#this-emit-…" class="headerlink" title="this.$emit(…)"></a>this.$emit(…)</h2><p>第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。<br>父组件:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/child'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>子组件:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$emit(<span class="string">'fatherMethod'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="方法传入子组件"><a href="#方法传入子组件" class="headerlink" title="方法传入子组件"></a>方法传入子组件</h2><p>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法<br>父组件:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/child'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'父组件'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>子组件:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      fatherMethod: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="literal">null</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.fatherMethod) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.fatherMethod();</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>三种都可以实现子组件调用父组件的方法，但是效率有所不同，根据实际需求选择合适的方法。</p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端图片格式转换</title>
      <link href="/2019/06/14/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/06/14/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="图片文件转base64"><a href="#图片文件转base64" class="headerlink" title="图片文件转base64"></a>图片文件转base64</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">change(file) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>,base64 = <span class="literal">null</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">    fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        base64 = fr.result;</span><br><span class="line">    &#125;;</span><br><span class="line">    fr.readAsDataURL(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="base64转2进制"><a href="#base64转2进制" class="headerlink" title="base64转2进制"></a>base64转2进制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">change(data, mime) &#123;</span><br><span class="line">data = data.split(<span class="string">','</span>)[<span class="number">1</span>];</span><br><span class="line">data = <span class="built_in">window</span>.atob(data);</span><br><span class="line"><span class="keyword">let</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">ia[i] = data.charCodeAt(i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Blob([ia], &#123;</span><br><span class="line">type: mime</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2进制转base64"><a href="#2进制转base64" class="headerlink" title="2进制转base64"></a>2进制转base64</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">change(bytes)&#123;</span><br><span class="line">    <span class="keyword">let</span> bString = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = bytes.length; i &lt; len; ++i)&#123;</span><br><span class="line">        bString += <span class="built_in">String</span>.fromCharCode(bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> btoa(bString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="canvas绘制和压缩图片"><a href="#canvas绘制和压缩图片" class="headerlink" title="canvas绘制和压缩图片"></a>canvas绘制和压缩图片</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">paint(base64, bili, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = base64;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">        <span class="keyword">let</span> w = <span class="keyword">this</span>.width / bili;</span><br><span class="line">        <span class="keyword">let</span> h = <span class="keyword">this</span>.height / bili;</span><br><span class="line">        canvas.setAttribute(<span class="string">"width"</span>, w);</span><br><span class="line">        canvas.setAttribute(<span class="string">"height"</span>, h);</span><br><span class="line">        canvas.getContext(<span class="string">"2d"</span>).drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="canvas转base64"><a href="#canvas转base64" class="headerlink" title="canvas转base64"></a>canvas转base64</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">let</span> base64 = canvas.toDataURL(<span class="string">"image/png"</span>);</span><br><span class="line"><span class="comment">//还可以传个参数做图片质量的设置，在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92</span></span><br></pre></td></tr></table></figure><h3 id="canvas转blob"><a href="#canvas转blob" class="headerlink" title="canvas转blob"></a>canvas转blob</h3><blockquote><p>HTMLCanvasElement.toBlob() 方法创造Blob对象，用以展示canvas上的图片</p></blockquote><p>void canvas.toBlob(callback, type, encoderOptions);</p><ul><li>callback<br>回调函数，可获得一个单独的Blob对象参数。</li><li>type 可选<br>DOMString类型，指定图片格式，默认格式为image/png。</li><li>encoderOptions 可选<br>Number类型，值在0与1之间，当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">&#125;, <span class="string">"image/jpeg"</span>);</span><br></pre></td></tr></table></figure><h3 id="base64转blob"><a href="#base64转blob" class="headerlink" title="base64转blob"></a>base64转blob</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataURItoBlob(base64Data) &#123;</span><br><span class="line">    <span class="keyword">let</span> byteString;</span><br><span class="line">    <span class="keyword">if</span>(base64Data.split(<span class="string">','</span>)[<span class="number">0</span>].indexOf(<span class="string">'base64'</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">        byteString = atob(base64Data.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        byteString = <span class="built_in">unescape</span>(base64Data.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> mimeString = base64Data.split(<span class="string">','</span>)[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>].split(<span class="string">';'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteString.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteString.length; i++) &#123;</span><br><span class="line">        ia[i] = byteString.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([ia], &#123;</span><br><span class="line">        type: mimeString</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-image-crop-upload裁剪组件</title>
      <link href="/2019/06/14/vue-image-crop-upload%E8%A3%81%E5%89%AA%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/06/14/vue-image-crop-upload%E8%A3%81%E5%89%AA%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/vicp1.png" alt="效果图"></p><p>npm地址<a href="https://www.npmjs.com/package/vue-image-crop-upload" target="_blank" rel="noopener">https://www.npmjs.com/package/vue-image-crop-upload</a></p><p>git地址<a href="https://github.com/dai-siki/vue-image-crop-upload" target="_blank" rel="noopener">https://github.com/dai-siki/vue-image-crop-upload</a></p><p>样例地址<a href="https://dai-siki.github.io/vue-image-crop-upload/example/demo.html" target="_blank" rel="noopener">https://dai-siki.github.io/vue-image-crop-upload/example/demo.html</a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">upload() &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            lang,</span><br><span class="line">            imgFormat,</span><br><span class="line">            mime,</span><br><span class="line">            url,</span><br><span class="line">            params,</span><br><span class="line">            headers,</span><br><span class="line">            field,</span><br><span class="line">            ki,</span><br><span class="line">            createImgUrl,</span><br><span class="line">            withCredentials</span><br><span class="line">        &#125; = <span class="keyword">this</span>,</span><br><span class="line">        fmData = <span class="keyword">new</span> FormData();</span><br><span class="line">    fmData.append(field, data2blob(createImgUrl, mime), field + <span class="string">'.'</span> + imgFormat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加其他参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> params == <span class="string">'object'</span> &amp;&amp; params) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(params).forEach(<span class="function">(<span class="params">k</span>) =&gt;</span> &#123;</span><br><span class="line">            fmData.append(k, params[k]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听进度回调</span></span><br><span class="line">    <span class="keyword">const</span> uploadProgress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">            that.progress = <span class="number">100</span> * <span class="built_in">Math</span>.round(event.loaded) / event.total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传文件</span></span><br><span class="line">    that.reset();</span><br><span class="line">    that.loading = <span class="number">1</span>;</span><br><span class="line">    that.setStep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);</span><br><span class="line">        client.withCredentials = withCredentials;</span><br><span class="line">        client.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span> || <span class="keyword">this</span>.status === <span class="number">201</span>) &#123;</span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.responseText));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">this</span>.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        client.upload.addEventListener(<span class="string">'progress'</span>, uploadProgress, <span class="literal">false</span>); <span class="comment">//监听进度</span></span><br><span class="line">        <span class="comment">// 设置header</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> headers == <span class="string">'object'</span> &amp;&amp; headers) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(headers).forEach(<span class="function">(<span class="params">k</span>) =&gt;</span> &#123;</span><br><span class="line">                client.setRequestHeader(k, headers[k]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        client.send(fmData);</span><br><span class="line">    &#125;).then(</span><br><span class="line">        <span class="comment">// 上传成功</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">resData</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (that.value) &#123;</span><br><span class="line">                that.loading = <span class="number">2</span>;</span><br><span class="line">                that.$emit(<span class="string">'crop-upload-success'</span>, resData, field, ki);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="comment">// 上传失败</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">sts</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (that.value) &#123;</span><br><span class="line">                that.loading = <span class="number">3</span>;</span><br><span class="line">                that.hasError = <span class="literal">true</span>;</span><br><span class="line">                that.errorMsg = lang.fail;</span><br><span class="line">                that.$emit(<span class="string">'crop-upload-fail'</span>, sts, field, ki);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点击波纹效果"><a href="#点击波纹效果" class="headerlink" title="点击波纹效果"></a>点击波纹效果</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">e, arg_opts</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> opts = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">ele: e.target, <span class="comment">// 波纹作用元素</span></span><br><span class="line">type: <span class="string">'hit'</span>, <span class="comment">// hit点击位置扩散　center中心点扩展</span></span><br><span class="line">bgc: <span class="string">'rgba(0, 0, 0, 0.15)'</span> <span class="comment">// 波纹颜色</span></span><br><span class="line">&#125;, arg_opts),</span><br><span class="line">target = opts.ele;</span><br><span class="line"><span class="keyword">if</span> (target) &#123;</span><br><span class="line"><span class="keyword">var</span> rect = target.getBoundingClientRect(),</span><br><span class="line">ripple = target.querySelector(<span class="string">'.e-ripple'</span>);</span><br><span class="line"><span class="keyword">if</span> (!ripple) &#123;</span><br><span class="line">ripple = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">ripple.className = <span class="string">'e-ripple'</span>;</span><br><span class="line">ripple.style.height = ripple.style.width = <span class="built_in">Math</span>.max(rect.width, rect.height) + <span class="string">'px'</span>;</span><br><span class="line">target.appendChild(ripple);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ripple.className = <span class="string">'e-ripple'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (opts.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'center'</span>:</span><br><span class="line">ripple.style.top = (rect.height / <span class="number">2</span> - ripple.offsetHeight / <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">ripple.style.left = (rect.width / <span class="number">2</span> - ripple.offsetWidth / <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ripple.style.top = (e.pageY - rect.top - ripple.offsetHeight / <span class="number">2</span> - <span class="built_in">document</span>.body.scrollTop) + <span class="string">'px'</span>;</span><br><span class="line">ripple.style.left = (e.pageX - rect.left - ripple.offsetWidth / <span class="number">2</span> - <span class="built_in">document</span>.body.scrollLeft) + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ripple.style.backgroundColor = opts.bgc;</span><br><span class="line">ripple.className = <span class="string">'e-ripple z-active'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="base64转2进制"><a href="#base64转2进制" class="headerlink" title="base64转2进制"></a>base64转2进制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">data, mime</span>) </span>&#123;</span><br><span class="line">data = data.split(<span class="string">','</span>)[<span class="number">1</span>];</span><br><span class="line">data = <span class="built_in">window</span>.atob(data);</span><br><span class="line"><span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">ia[i] = data.charCodeAt(i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// canvas.toDataURL 返回的默认格式就是 image/png</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Blob([ia], &#123;</span><br><span class="line">type: mime</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-dev-server的proxy用法</title>
      <link href="/2019/06/13/Webpack-dev-server%E7%9A%84proxy%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/13/Webpack-dev-server%E7%9A%84proxy%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li>如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。</li><li>解决开发环境的跨域问题(不用在去配置nginx和host)</li></ol><h3 id="在webpack-config-js中配置"><a href="#在webpack-config-js中配置" class="headerlink" title="在webpack.config.js中配置"></a>在webpack.config.js中配置</h3><p>下面简单介绍一下五个经常使用的场景</p><h4 id="使用一"><a href="#使用一" class="headerlink" title="使用一"></a>使用一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mmodule.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: <span class="string">'http://localhost:3000'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请求到 /api/xxx 现在会被代理到请求 localhost:3000/api/xxx, 例如 /api/user现在会被代理到请求 localhost:3000/api/user</p><h4 id="使用二"><a href="#使用二" class="headerlink" title="使用二"></a>使用二</h4><p>如果你想要代码多个路径代理到同一个target下, 你可以使用由一个或多个「具有 context 属性的对象」构成的数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: [<span class="string">'/auth'</span>, <span class="string">'/api'</span>],</span><br><span class="line">            target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="使用三"><a href="#使用三" class="headerlink" title="使用三"></a>使用三</h4><p>如果你不想始终传递 /api ，则需要重写路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">                pathRewrite: &#123;<span class="string">'^/api'</span> : <span class="string">''</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>请求到 /api/xxx 现在会被代理到请求 localhost:3000/xxx, 例如 /api/user 现在会被代理到请求 localhost:3000/user</p><h4 id="使用四"><a href="#使用四" class="headerlink" title="使用四"></a>使用四</h4><p>默认情况下，不接受运行在 HTTPS 上，且使用了无效证书的后端服务器。如果你想要接受，只要设置 secure: false 就行。修改配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'https://other-server.example.com'</span>,</span><br><span class="line">                secure: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="使用五"><a href="#使用五" class="headerlink" title="使用五"></a>使用五</h4><p>有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理。<br>在函数中你可以访问请求体、响应体和代理选项。必须返回 false 或路径，来跳过代理请求。<br>例如：对于浏览器请求，你想要提供一个 HTML 页面，但是对于 API 请求则保持代理。你可以这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">                bypass: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, proxyOptions</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (req.headers.accept.indexOf(<span class="string">'html'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'Skipping proxy for browser request.'</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">'/index.html'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="解决跨域原理"><a href="#解决跨域原理" class="headerlink" title="解决跨域原理"></a>解决跨域原理</h3><p>上面的参数列表中有一个changeOrigin参数, 是一个布尔值, 设置为true, 本地就会虚拟一个服务器接收你的请求并代你发送该请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="vue-cli中proxyTable配置接口地址代理示例"><a href="#vue-cli中proxyTable配置接口地址代理示例" class="headerlink" title="vue-cli中proxyTable配置接口地址代理示例"></a>vue-cli中proxyTable配置接口地址代理示例</h3><p>修改 config/index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dev: &#123;</span><br><span class="line">    <span class="comment">// 静态资源文件夹</span></span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    <span class="comment">// 发布路径</span></span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理配置表，在这里可以配置特定的请求代理到对应的API接口</span></span><br><span class="line">    <span class="comment">// 使用方法：https://vuejs-templates.github.io/webpack/proxy.html</span></span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">        <span class="comment">// 例如将'localhost:8080/api/xxx'代理到'https://wangyaxing.cn/api/xxx'</span></span><br><span class="line">        <span class="string">'/api'</span>: &#123;</span><br><span class="line">            target: <span class="string">'https://wangyaxing.cn'</span>, <span class="comment">// 接口的域名</span></span><br><span class="line">            secure: <span class="literal">false</span>,  <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>, <span class="comment">// 如果接口跨域，需要进行这个参数配置</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 例如将'localhost:8080/img/xxx'代理到'https://cdn.wangyaxing.cn/xxx'</span></span><br><span class="line">        <span class="string">'/img'</span>: &#123;</span><br><span class="line">            target: <span class="string">'https://cdn.wangyaxing.cn'</span>, <span class="comment">// 接口的域名</span></span><br><span class="line">            secure: <span class="literal">false</span>,  <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>, <span class="comment">// 如果接口跨域，需要进行这个参数配置</span></span><br><span class="line">            pathRewrite: &#123;<span class="string">'^/img'</span>: <span class="string">''</span>&#125;  <span class="comment">// pathRewrite 来重写地址，将前缀 '/api' 转为 '/'。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Various Dev Server settings</span></span><br><span class="line">    host: <span class="string">'localhost'</span>, <span class="comment">// can be overwritten by process.env.HOST</span></span><br><span class="line">    port: <span class="number">4200</span>, <span class="comment">// can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h3><p>dev-server 使用了非常强大的 http-proxy-middleware , http-proxy-middleware 基于 http-proxy 实现的，可以查看 http-proxy 的源码和文档:<a href="https://github.com/nodejitsu/node-http-proxy。" target="_blank" rel="noopener">https://github.com/nodejitsu/node-http-proxy。</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">target：要使用url模块解析的url字符串</span><br><span class="line">forward：要使用url模块解析的url字符串</span><br><span class="line">agent：要传递给http（s）.request的对象（请参阅Node的https代理和http代理对象）</span><br><span class="line">ssl：要传递给https.createServer（）的对象</span><br><span class="line">ws：<span class="literal">true</span> / <span class="literal">false</span>，是否代理websockets</span><br><span class="line">xfwd：<span class="literal">true</span> / <span class="literal">false</span>，添加x-forward标头</span><br><span class="line">secure：<span class="literal">true</span> / <span class="literal">false</span>，是否验证SSL Certs</span><br><span class="line">toProxy：<span class="literal">true</span> / <span class="literal">false</span>，传递绝对URL作为路径（对代理代理很有用）</span><br><span class="line">prependPath：<span class="literal">true</span> / <span class="literal">false</span>，默认值：<span class="literal">true</span> - 指定是否要将目标的路径添加到代理路径</span><br><span class="line">ignorePath：<span class="literal">true</span> / <span class="literal">false</span>，默认值：<span class="literal">false</span> - 指定是否要忽略传入请求的代理路径（注意：如果需要，您必须附加/手动）。</span><br><span class="line">localAddress：要为传出连接绑定的本地接口字符串</span><br><span class="line">changeOrigin：<span class="literal">true</span> / <span class="literal">false</span>，默认值：<span class="literal">false</span> - 将主机标头的原点更改为目标URL</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://webpack.docschina.org/configuration/dev-server/#devserver-proxy" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a></li><li><a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="noopener">node-http-proxy</a></li><li><a href="https://vuejs-templates.github.io/webpack/proxy.html" target="_blank" rel="noopener">API Proxying During Development</a></li></ul><p>转载自</p><ul><li><a href="https://www.jianshu.com/p/f489e7764cb8" target="_blank" rel="noopener">Webpack-dev-server的proxy用法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WebPack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts实现图表间联动</title>
      <link href="/2019/06/13/Echarts%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%A1%8C%E4%B8%BA/"/>
      <url>/2019/06/13/Echarts%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>Echarts.js目前已经提供了connect功能，只要图标的legend一样，那么就能实现联动。<br>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myChart1 = <span class="keyword">this</span>.$echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main1'</span>));</span><br><span class="line"><span class="keyword">var</span> myChart2 = <span class="keyword">this</span>.$echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main2'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: <span class="string">'ECharts 入门示例'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        show : <span class="literal">true</span>,</span><br><span class="line">        feature : &#123;</span><br><span class="line">            mark : &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            dataView : &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">readOnly</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">            magicType : &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">type</span>: [<span class="string">'line'</span>, <span class="string">'bar'</span>, <span class="string">'stack'</span>, <span class="string">'tiled'</span>]&#125;,</span><br><span class="line">            restore : &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            saveAsImage : &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data:[<span class="string">'销量'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        data: [<span class="string">"衬衫"</span>,<span class="string">"羊毛衫"</span>,<span class="string">"雪纺衫"</span>,<span class="string">"裤子"</span>,<span class="string">"高跟鞋"</span>,<span class="string">"袜子"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;&#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name: <span class="string">'销量'</span>,</span><br><span class="line">        type: <span class="string">'line'</span>,</span><br><span class="line">        data: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myChart1.setOption(option);</span><br><span class="line">myChart2.setOption(option);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制联动的</span></span><br><span class="line"><span class="keyword">this</span>.$echarts.connect([myChart1,myChart2]);</span><br></pre></td></tr></table></figure></p><p>效果如下面的示例图，当鼠标经过图1的时候，这个时候有提示，然后让图2的提示也显示出来<br><img src="/img/echarts-connect.png" alt></p><p>如何关联？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别设置每个实例的 group id</span></span><br><span class="line">chart1.group = <span class="string">'group1'</span>;</span><br><span class="line">chart2.group = <span class="string">'group1'</span>;</span><br><span class="line">echarts.connect(<span class="string">'group1'</span>);</span><br><span class="line"><span class="comment">// 或者可以直接传入需要联动的实例数组</span></span><br><span class="line">echarts.connect([chart1, chart2]);</span><br></pre></td></tr></table></figure></p><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>ECharts 4 开始支持了 dataset 组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以基于数据指定数据到视觉的映射。这在不少场景下能带来使用上的方便。<br>dataset简单示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    legend: &#123;&#125;,</span><br><span class="line">    tooltip: &#123;&#125;,</span><br><span class="line">    dataset: &#123;</span><br><span class="line">        <span class="comment">// 提供一份数据。</span></span><br><span class="line">        source: [</span><br><span class="line">            [<span class="string">'product'</span>, <span class="string">'2015'</span>, <span class="string">'2016'</span>, <span class="string">'2017'</span>],</span><br><span class="line">            [<span class="string">'Matcha Latte'</span>, <span class="number">43.3</span>, <span class="number">85.8</span>, <span class="number">93.7</span>],</span><br><span class="line">            [<span class="string">'Milk Tea'</span>, <span class="number">83.1</span>, <span class="number">73.4</span>, <span class="number">55.1</span>],</span><br><span class="line">            [<span class="string">'Cheese Cocoa'</span>, <span class="number">86.4</span>, <span class="number">65.2</span>, <span class="number">82.5</span>],</span><br><span class="line">            [<span class="string">'Walnut Brownie'</span>, <span class="number">72.4</span>, <span class="number">53.9</span>, <span class="number">39.1</span>]</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 声明一个 X 轴，类目轴（category）。默认情况下，类目轴对应到 dataset 第一列。</span></span><br><span class="line">    xAxis: &#123;<span class="attr">type</span>: <span class="string">'category'</span>&#125;,</span><br><span class="line">    <span class="comment">// 声明一个 Y 轴，数值轴。</span></span><br><span class="line">    yAxis: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。</span></span><br><span class="line">    series: [</span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">'bar'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">'bar'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">'bar'</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图如下：<br><img src="/img/echarts-dataset-link.png" alt><br><a href="http://echarts.baidu.com/examples/editor.html?c=dataset-link" target="_blank" rel="noopener">来源 http://echarts.baidu.com/examples/editor.html?c=dataset-link</a></p><p>在这个样例中，随着鼠标在坐标轴上的移动，饼图会不断的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">myChart.on(<span class="string">'updateAxisPointer'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xAxisInfo = event.axesInfo[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (xAxisInfo) &#123;</span><br><span class="line">        <span class="keyword">var</span> dimension = xAxisInfo.value + <span class="number">1</span>;</span><br><span class="line">        myChart.setOption(&#123;</span><br><span class="line">            series: &#123;</span><br><span class="line">                id: <span class="string">'pie'</span>,</span><br><span class="line">                label: &#123;</span><br><span class="line">                    formatter: <span class="string">'&#123;b&#125;: &#123;@['</span> + dimension + <span class="string">']&#125; (&#123;d&#125;%)'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                encode: &#123;</span><br><span class="line">                    value: dimension,</span><br><span class="line">                    tooltip: dimension</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>本质上是通过鼠标事件，不断获取xAxisInfo，然后根据获取到的xAxisInfo.value(dimension)重新绘制饼图。这个可视化过程中数据是以数据集形式呈现的，所以用的encode，具体介绍可以在<a href="https://www.echartsjs.com/tutorial.html#%E4%BD%BF%E7%94%A8%20dataset%20%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">https://www.echartsjs.com/tutorial.html#%E4%BD%BF%E7%94%A8%20dataset%20%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE</a> 看到。</p><h3 id="通过事件"><a href="#通过事件" class="headerlink" title="通过事件"></a>通过事件</h3><p><a href="https://www.echartsjs.com/tutorial.html#ECharts%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%A1%8C%E4%B8%BA" target="_blank" rel="noopener">Echarts事件介绍</a></p><p>ECharts 中的事件分为两种，一种是鼠标事件，在鼠标点击某个图形上会触发，还有一种是 调用 dispatchAction 后触发的事件。</p><p>ECharts 中支持的图表行为，通过 dispatchAction 触发<br><a href="https://www.echartsjs.com/api.html#action" target="_blank" rel="noopener">action</a></p><p>在 ECharts 中主要通过 on 方法添加事件处理函数，该文档描述了所有 ECharts 的事件列表。<br><a href="https://www.echartsjs.com/api.html#events" target="_blank" rel="noopener">events</a></p><p>之所以可以使用这个实现多图联动，实质上是一个图上发生鼠标移动事件后，调用另一个图，使其产生动作。比如mychart1和mychart2，如果获取到了mychart1的params信息，通过这些信息可以对应到mychart2的dataIndex、SeriesIndex，那么，就可以用这样的形式实现联动。</p><h4 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myChart.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这个方法有一个不友好的地方就是只有用户点击到图中如：点、线、柱状图等上才可以触发点击事件，点击那一列的其他位置是没有作用的，因此我找到了另外一种方法实现这个需求，通过点击所在值的这一列就会触发（区域点击事件），实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myChart.getZr().on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> point=[params.offsetX,params.offsetY];</span><br><span class="line">    <span class="keyword">if</span>(myChart.containPixel(<span class="string">'gird'</span>,point))&#123;</span><br><span class="line">        <span class="keyword">let</span> xIndex=myChart.convertFromPixel(&#123;<span class="attr">seriesIndex</span>:<span class="number">0</span>&#125;,</span><br><span class="line">              point)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> op=myChart.getOption();</span><br><span class="line">        <span class="keyword">let</span> name=op.xAxis[<span class="number">0</span>].data[xIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="myChart-setOption"><a href="#myChart-setOption" class="headerlink" title="myChart.setOption"></a>myChart.setOption</h4><p>重新绘制</p><h4 id="myChart-dispatchAction"><a href="#myChart-dispatchAction" class="headerlink" title="myChart.dispatchAction"></a>myChart.dispatchAction</h4><p>触发图表行为，例如图例开关legendToggleSelect, 数据区域缩放dataZoom，显示提示框showTip等等，更多见官方文档。</p><p>payload 参数可以通过batch属性同时触发多个行为。</p><blockquote><p>注：在 ECharts 2.x 是通过 myChart.component.tooltip.showTip 这种形式调用相应的接口触发图表行为，入口很深，而且涉及到内部组件的组织。因此在 ECharts 3 里统一改为 dispatchAction 的形式。</p></blockquote><p>示例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">myChart.dispatchAction(&#123;</span><br><span class="line">    type: <span class="string">'dataZoom'</span>,</span><br><span class="line">    start: <span class="number">20</span>,</span><br><span class="line">    end: <span class="number">30</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 可以通过 batch 参数批量分发多个 action</span></span><br><span class="line">myChart.dispatchAction(&#123;</span><br><span class="line">    type: <span class="string">'dataZoom'</span>,</span><br><span class="line">    batch: [&#123;</span><br><span class="line">        <span class="comment">// 第一个 dataZoom 组件</span></span><br><span class="line">        start: <span class="number">20</span>,</span><br><span class="line">        end: <span class="number">30</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="comment">// 第二个 dataZoom 组件</span></span><br><span class="line">        dataZoomIndex: <span class="number">1</span>,</span><br><span class="line">        start: <span class="number">10</span>,</span><br><span class="line">        end: <span class="number">20</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初级后端工程师进阶</title>
      <link href="/2019/06/12/%E5%88%9D%E7%BA%A7%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6/"/>
      <url>/2019/06/12/%E5%88%9D%E7%BA%A7%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/learn-backend.png" alt></p><blockquote><p>Stay Hungry,Stay Foolish<br>初级后端工程师进阶</p></blockquote><h3 id="Javascript-amp-ES6-熟悉"><a href="#Javascript-amp-ES6-熟悉" class="headerlink" title="Javascript&amp;ES6(熟悉)"></a>Javascript&amp;ES6(熟悉)</h3><p>​<br>[1]    目标:可以熟练掌握Javascript和ES6的语法，可以在项目中熟练使用基本语法，可以使用Promise处理复杂回调。知道语言的Good Parts和Bad Parts。<br>[2]    推荐书籍:<br>    &emsp;a.  《ES6标准入门》<br>    &emsp;b.  《Javascript语言精粹》<br>    &emsp;c.  《Javascript高级程序指南》<br>[3]    推荐在线教程:<br>    &emsp;a.  <a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">ES6入门</a><br>    &emsp;b.  <a href="https://codeguide.bootcss.com/" target="_blank" rel="noopener">HTML/CSS/JS编码规范</a><br>    &emsp;c.  <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143470025281435e4e03117a74438aaf98c4f7b30b307000" target="_blank" rel="noopener">廖雪峰的javascript教程</a><br>[4]    推荐工具:<br>    &emsp;a.  VSCode<br>    &emsp;b.  <a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">ESlint</a></p><h3 id="Python-amp-Flask-精通"><a href="#Python-amp-Flask-精通" class="headerlink" title="Python &amp; Flask(精通)"></a>Python &amp; Flask(精通)</h3><p>​<br>[1]    目标:熟练掌握Python 3.6语法，可以使用Flask实现类restful service的api。<br>[2]    推荐书籍:N.A.<br>[3]    推荐在线教程:<br>    &emsp;a.  <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的python教程</a><br>    &emsp;b.  <a href="https://docs.python.org/3.6/" target="_blank" rel="noopener">python官方文档</a><br>[4] 推荐工具:<br>    &emsp;a.  pycharm</p><h3 id="MongoDB-熟悉"><a href="#MongoDB-熟悉" class="headerlink" title="MongoDB(熟悉)"></a>MongoDB(熟悉)</h3><p>​<br>[1] 目标:熟练掌握MongoDB基础知识，可以使用MongoDB为Web服务提供数据存储<br>[2] 推荐书籍:<br>    &emsp;a.  《MongoDB权威指南》<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://docs.mongodb.com/?_ga=2.120015240.1062691917.1537102196-1035018505.1537102196" target="_blank" rel="noopener">mongodb官方文档</a><br>[4] 推荐工具:<br>    &emsp;a.  robo 3t</p><h3 id="HTML-amp-HTML5-熟悉"><a href="#HTML-amp-HTML5-熟悉" class="headerlink" title="HTML&amp;HTML5(熟悉)"></a>HTML&amp;HTML5(熟悉)</h3><p>[1]    目标:熟练掌握HTML/HTML5的语法特性，熟悉HTML5所有标签以及API。<br>[2]    推荐书籍:<br>    &emsp;a.  《HTML5秘籍》<br>[3]    推荐在线教程:<br>    &emsp;a.  <a href="https://www.w3cschool.cn/html5/" target="_blank" rel="noopener">W3CSchool教程</a><br>[4]    推荐工具:<br>    &emsp;a.  VSCode</p><h3 id="CSS-amp-CSS3-熟悉"><a href="#CSS-amp-CSS3-熟悉" class="headerlink" title="CSS&amp;CSS3(熟悉)"></a>CSS&amp;CSS3(熟悉)</h3><p>​<br>[1]    目标:熟练掌握CSS3特性，可以使用CSS实现常用的布局与动画效果。<br>[2]    推荐书籍:N.A.<br>[3]    推荐在线教程:<br>    &emsp;a.  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN</a><br>    &emsp;b.  <a href="http://www.w3school.com.cn/css3/index.asp" target="_blank" rel="noopener">W3CSchool</a><br>[4]    推荐工具:<br>    &emsp;a.  vscode<br>    &emsp;b.  <a href="https://css.doyoe.com/" target="_blank" rel="noopener">css参考手册</a><br>    &emsp;c.  <a href="https://fontawesome.com/" target="_blank" rel="noopener">icon库</a><br>    &emsp;d.  <a href="https://www.sasscss.com/sass-guidelines/" target="_blank" rel="noopener">SASS</a></p><h3 id="HTTP-amp-HTTPS协议-精通"><a href="#HTTP-amp-HTTPS协议-精通" class="headerlink" title="HTTP&amp;HTTPS协议(精通)"></a>HTTP&amp;HTTPS协议(精通)</h3><p>​<br>[1]    目标:掌握HTTP协议的通信原理，在前后端调试中，可以理解HTTP报文请求的含义。可以使用HTTP对前端开发进行性能优化。理解HTTPS的安全性原理，可以在实际使用中使用HTTPS进行安全通信。<br>[2]    推荐书籍:<br>    &emsp;a.  《图解HTTP》<br>[3]    推荐在线教程:<br>    &emsp;a.  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">MDN</a><br>    &emsp;b.  <a href="https://zhuanlan.zhihu.com/p/27395037" target="_blank" rel="noopener">HTTPS</a><br>    &emsp;c.  <a href="http://support.upyun.com/hc/kb/article/1048799/" target="_blank" rel="noopener">HTTP2协议</a><br>[4]    推荐工具:<br>    &emsp;a.  Google Chrome Developer Tools<br>    &emsp;b.  Postman<br>    &emsp;c.  Google Page Spead</p><h3 id="Bootstrap-3-了解"><a href="#Bootstrap-3-了解" class="headerlink" title="Bootstrap 3(了解)"></a>Bootstrap 3(了解)</h3><p>[1] 目标:熟练使用Bootstrap3进行响应式页面的开发，理解栅格系统，熟悉常用的组件与js api。<br>[2] 推荐书籍:N.A.<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://v3.bootcss.com/" target="_blank" rel="noopener">https://v3.bootcss.com/</a><br>[4] 推荐工具:N.A.</p><h3 id="jQuery-了解"><a href="#jQuery-了解" class="headerlink" title="jQuery(了解)"></a>jQuery(了解)</h3><p>​<br>[1] 目标:熟练掌握jQuery语法与API使用，可以使用jQuery进行Dom操作与网络请求<br>[2] 推荐书籍:N.A.<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://api.jquery.com/" target="_blank" rel="noopener">jQuery官方文档</a><br>    &emsp;b.  <a href="https://www.quanzhanketang.com/jquery/default.html" target="_blank" rel="noopener">快速入门</a><br>[4] 推荐工具:N.A.</p><h3 id="Vue-熟悉"><a href="#Vue-熟悉" class="headerlink" title="Vue(熟悉)"></a>Vue(熟悉)</h3><p>​<br>[1] 目标:熟练掌握Vue的框架特性与常用语法，可以使用Vue快速构建Web应用。<br>[2] 推荐书籍:N.A.<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">https://cn.vuejs.org/index.html</a><br>[4] 推荐工具:N.A.</p><h3 id="Webpack-了解"><a href="#Webpack-了解" class="headerlink" title="Webpack (了解)"></a>Webpack (了解)</h3><p>[1] 目标:熟练掌握Webpack框架、语法，可以使用Webpack实现Web前端打包。<br>[2] 推荐书籍:N.A.<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">https://www.webpackjs.com/concepts/</a><br>[4] 推荐工具:N.A.</p><h3 id="Git-熟悉"><a href="#Git-熟悉" class="headerlink" title="Git(熟悉)"></a>Git(熟悉)</h3><p>[1] 目标: 熟悉Git基本语法与流程，可以使用类Gitflow流程进行源代码管理。<br>[2] 推荐书籍:<br>    &emsp;a.  《Git版本控制管理》<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://progit.bootcss.com/" target="_blank" rel="noopener">progit</a><br>[4] 推荐工具<br>    &emsp;a.  sourcetree<br>    &emsp;b.  gitkraken</p><h3 id="NodeJS-amp-Npm-熟悉"><a href="#NodeJS-amp-Npm-熟悉" class="headerlink" title="NodeJS &amp; Npm(熟悉)"></a>NodeJS &amp; Npm(熟悉)</h3><p>​<br>[1] 目标: 了解NodeJS和Npm的feature,可以使用npm安装常用包，使用NodeJS开发类Restful的api。<br>[2] 推荐书籍:<br>    &emsp;a.  《深入浅出nodejs》<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://nodejs.org/dist/latest-v8.x/docs/api/" target="_blank" rel="noopener">https://nodejs.org/dist/latest-v8.x/docs/api/</a><br>    &emsp;b.  <a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">https://www.npmjs.com.cn/</a><br>[4] 推荐工具:N.A.<br>​​</p><h3 id="Docker-掌握"><a href="#Docker-掌握" class="headerlink" title="Docker(掌握)"></a>Docker(掌握)</h3><p>​<br>[1] 目标: 掌握Docker基础知识，可以使用docker部署后端项目。<br>[2] 推荐书籍:<br>    &emsp;a.  《Docker技术入门与实战》<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://docs.docker.com/" target="_blank" rel="noopener">docker官方文档</a><br>[4] 推荐工具:N.A.<br>​​</p><h3 id="Linux-and-Shell-掌握"><a href="#Linux-and-Shell-掌握" class="headerlink" title="Linux and Shell(掌握)"></a>Linux and Shell(掌握)</h3><p>​<br>[1] 目标: 了解Linux操作系统基本特性，熟练掌握常用的Shell命令<br>[2] 推荐书籍:<br>    &emsp;a.  《鸟哥的Linux私房菜》<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://www.imooc.com/course/list?c=linux" target="_blank" rel="noopener">https://www.imooc.com/course/list?c=linux</a><br>[4] 推荐工具:<br>    &emsp;a.  Ubuntu 16.04 LTS<br>​​</p><h3 id="Nginx服务器-掌握"><a href="#Nginx服务器-掌握" class="headerlink" title="Nginx服务器(掌握)"></a>Nginx服务器(掌握)</h3><p>​<br>[1] 目标: 熟悉Nginx服务器知识，会使用Nginx搭建web服务容器。<br>[2] 推荐书籍:<br>    &emsp;a.  《深入理解Nginx:模块开发与架构解析》<br>[3] 推荐教程:<br>    &emsp;a.  <a href="https://www.w3cschool.cn/nginx/" target="_blank" rel="noopener">https://www.w3cschool.cn/nginx/</a><br>[4] 推荐工具:N.A.</p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 读书 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品学习</title>
      <link href="/2019/06/12/%E4%BA%A7%E5%93%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/06/12/%E4%BA%A7%E5%93%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="交互学习"><a href="#交互学习" class="headerlink" title="交互学习"></a>交互学习</h3><ul><li><a href="http://www.woshipm.com/ucd/1489258.html" target="_blank" rel="noopener">人机交互指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/35184751" target="_blank" rel="noopener">人机交互指南2018中文版</a></li><li><a href="https://uiiiuiii.com/screen/ios.htm" target="_blank" rel="noopener">Ios设计规范</a></li></ul><h3 id="常用交互软件"><a href="#常用交互软件" class="headerlink" title="常用交互软件"></a>常用交互软件</h3><ul><li>Axure</li><li><a href="https://creative.adobe.com/zh-cn/products/download/xd" target="_blank" rel="noopener">XD</a></li><li>Sketch用于小图标</li><li>Xmind或Mindmanager</li></ul><h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><ul><li>《触动人心》</li><li>《启示录》</li><li>《点石成金》</li><li>《写给大家看的设计书》</li><li>《交互设计之路》</li><li>《情感化设计》</li><li>《可用性工程》</li><li>《简约至上：交互式设计四策略》</li><li>《设计中的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些好用的插件</title>
      <link href="/2019/06/12/vue%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/06/12/vue%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">element-ui</a> - 饿了么开发的一套为开发者、设计师和产品经理准备的基于Vue2.0的桌面端组件库</li><li><a href="https://www.iviewui.com/" target="_blank" rel="noopener">iview</a> - 一套基于Vue.js的高质量UI组件库</li><li><a href="https://vuetifyjs.com/zh-Hans/" target="_blank" rel="noopener">vuetify</a> - 为移动而生的Vue组件框架</li><li><a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">mint-ui</a> - 基于 Vue.js 的移动端组件库</li><li><a href="https://youzan.github.io/vant/#/zh-CN/intro" target="_blank" rel="noopener">vant</a> - 轻量、可靠的移动端Vue组件库</li><li><a href="https://muse-ui.org/#/zh-CN" target="_blank" rel="noopener">muse-ui</a> - 三端样式一致的响应式UI库</li><li><a href="https://fe-driver.github.io/vue-beauty" target="_blank" rel="noopener">vue-beauty</a> - 由vue和ant design创建的优美UI组件</li></ul><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><ul><li><a href="https://github.com/wangdahoo/vue-scroller" target="_blank" rel="noopener">vue-scroller</a> - Vonic UI的功能性组件</li><li><a href="https://github.com/PeachScript/vue-infinite-loading" target="_blank" rel="noopener">vue-infinite-loading</a> - VueJS的无限滚动插件</li><li><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a> - 带任意数目数据的顺畅的滚动</li><li><a href="https://github.com/ElemeFE/vue-infinite-scroll" target="_blank" rel="noopener">vue-infinite-scroll</a> - VueJS的无限滚动指令</li></ul><h3 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h3><ul><li><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">vue-awesome-swiper</a> - vue.js触摸滑动组件</li></ul><h3 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h3><ul><li><a href="https://github.com/surmon-china/vue-quill-editor" target="_blank" rel="noopener">vue-quill-editor</a> - 基于Quill适用于Vue2的富文本编辑器</li><li><a href="https://github.com/ajaxorg/ace" target="_blank" rel="noopener">Ace</a> - 一个开源的、独立的、基于浏览器的代码编辑器</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul><li><a href="https://github.com/lian-yue/vue-upload-component" target="_blank" rel="noopener">vue-upload-component</a> - Vuejs文件上传组件</li><li><a href="https://github.com/Vanthink-UED/vue-core-image-upload" target="_blank" rel="noopener">vue-core-image-upload</a> - 轻量级的vue上传插件</li><li><a href="https://www.npmjs.com/package/vue-image-crop-upload" target="_blank" rel="noopener">vue-image-crop-upload</a> - vue图片剪裁上传组件</li></ul><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><ul><li><a href="https://github.com/xyxiao001/vue-cropper" target="_blank" rel="noopener">vue-cropper</a> - 一个优雅的图片裁剪插件</li></ul><h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3><ul><li><a href="https://www.npmjs.com/package/vuedraggable" target="_blank" rel="noopener">Vue.Draggable</a> - Draggable为基于Sortable.js的vue组件，用以实现拖拽功能</li><li><a href="https://github.com/jbaysolutions/vue-grid-layout" target="_blank" rel="noopener">vue-grid-layout</a> - 实现桌面拖拽布局</li></ul><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><ul><li><a href="https://www.echartsjs.com/" target="_blank" rel="noopener">Echarts</a> - ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）</li><li><a href="http://antv.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">AntV</a> - AntV是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践</li><li><a href="https://www.highcharts.com.cn/" target="_blank" rel="noopener">HighCharts</a> - 兼容 IE6+、完美支持移动端、图表类型丰富、方便快捷的 HTML5 交互性图表库</li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/06/11/test/"/>
      <url>/2019/06/11/test/</url>
      
        <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.exa</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.selector</span>, <span class="selector-class">.selector-secondary</span>, <span class="selector-class">.selector</span><span class="selector-attr">[type=text]</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(0, 0, 0, 0.5);</span><br><span class="line">        <span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#CCC</span>,inset <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#FFFFFF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Recommended */</span></span><br><span class="line">    <span class="selector-class">.selector</span>,</span><br><span class="line">    <span class="selector-class">.selector-secondary</span>,</span><br><span class="line">    <span class="selector-class">.selector</span><span class="selector-attr">[type="text"]</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,.5);</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#ccc</span>, inset <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> humanities </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue修饰符</title>
      <link href="/2019/06/11/vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2019/06/11/vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了方便大家写代码，vue.js给大家提供了很多方便的修饰符，比如我们经常用到的取消冒泡，阻止默认事件等等</p></blockquote><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.lazy</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样只有当我们光标离开输入框的时候，它才会更新视图，相当于在onchange事件触发更新。</p><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><p>我们经常需要过滤一下一些输入框中无意键入的空格，这时可以给v-model添加trim修饰符。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.trim</span>=<span class="string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果你先输入数字，那它就会限制你输入的只能是数字。<br>如果你先输入字符串，那它就相当于没有加.number</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><h4 id="stop"><a href="#stop" class="headerlink" title=".stop"></a>.stop</h4><p>由于事件冒泡的机制，我们给元素绑定点击事件的时候，也会触发父级的点击事件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"test(2)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//js</span><br><span class="line">test(e)&#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">//1</span><br><span class="line">//2</span><br></pre></td></tr></table></figure></p><p>给click事件绑定stop修饰符可以一键阻止事件冒泡，相当于调用了event.stopPropagation()方法。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"test(2)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"test(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//1</span><br></pre></td></tr></table></figure></p><h4 id="prevent"><a href="#prevent" class="headerlink" title=".prevent"></a>.prevent</h4><p>用于阻止事件的默认行为，例如，当点击提交按钮时阻止对表单的提交。相当于调用了event.preventDefault()方法。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：修饰符可以同时使用多个,但是可能会因为顺序而有所不同。<br>用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。<br>也就是从左往右判断。</p></blockquote><h4 id="self"><a href="#self" class="headerlink" title=".self"></a>.self</h4><p>只当事件是从事件绑定的元素本身触发时才触发回调。像下面所示，刚刚我们从.stop时候知道子元素会冒泡到父元素导致触发父元素的点击事件，当我们加了这个.self以后，我们点击button不会触发父元素的点击事件test，只有当点击到父元素的时候（蓝色背景）才会test~从这个self的英文翻译过来就是‘自己，本身’可以看出这个修饰符的用法<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span> @<span class="attr">click.self</span>=<span class="string">"test(2)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="once"><a href="#once" class="headerlink" title=".once"></a>.once</h4><p>这个修饰符绑定了事件以后只能触发一次，第二次就不会触发。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">"test(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。</p><h4 id="capture"><a href="#capture" class="headerlink" title=".capture"></a>.capture</h4><p>从上面我们知道了事件的冒泡，其实完整的事件机制是：捕获阶段–目标阶段–冒泡阶段。<br>默认的呢，是事件触发是从目标开始往上冒泡。<br>当我们加了这个.capture以后呢，我们就反过来了，事件触发从包含这个元素的顶层开始往下触发。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">"test(1)"</span>&gt;</span></span><br><span class="line">   obj1</span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">"test(2)"</span>&gt;</span></span><br><span class="line">     obj2</span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"test(3)"</span>&gt;</span></span><br><span class="line">       obj3</span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"test(4)"</span>&gt;</span></span><br><span class="line">         obj4</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> // 1 2 4 3</span><br></pre></td></tr></table></figure></p><p>从上面这个例子我们点击obj4的时候，就可以清楚地看出区别，obj1，obj2在捕获阶段就触发了事件，因此是先1后2，后面的obj3，obj4是默认的冒泡阶段触发，因此是先4然后冒泡到3。</p><h4 id="passive"><a href="#passive" class="headerlink" title=".passive"></a>.passive</h4><p>当我们在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。</p></blockquote><h4 id="native"><a href="#native" class="headerlink" title=".native"></a>.native</h4><p>我们经常会写很多的小组件，有些小组件可能会绑定一些事件，但是，像下面这样绑定事件是不会触发的<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">My-component</span> @<span class="attr">click</span>=<span class="string">"test(3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">My-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>必须使用.native来修饰这个click事件（即<my-component @click.native="test(3)"></my-component>），可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，</p><blockquote><p>注意：使用.native修饰符来操作普通HTML标签是会令事件失效的</p></blockquote><h3 id="v-bind修饰符"><a href="#v-bind修饰符" class="headerlink" title="v-bind修饰符"></a>v-bind修饰符</h3><h4 id="sync-2-3-0-新增"><a href="#sync-2-3-0-新增" class="headerlink" title=".sync(2.3.0+ 新增)"></a>.sync(2.3.0+ 新增)</h4><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p><p>这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle)</span><br></pre></td></tr></table></figure></p><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>:title.sync=”isShow”其实是 @update:title=”tmp=&gt;title=tmp”语法糖。是其一种简写形式。</p><blockquote><p>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</p></blockquote><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">"doc"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。</p><blockquote><p>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><h4 id="prop"><a href="#prop" class="headerlink" title=".prop"></a>.prop</h4><p>要学习这个修饰符，我们首先要搞懂两个东西的区别。<br>Property：节点对象在内存中存储的属性，可以访问和设置。<br>Attribute：节点对象的其中一个属性( property )，值是一个对象，可以通过点访问法 document.getElementById(‘xx’).attributes 或者 document.getElementById(‘xx’).getAttributes(‘xx’) 读取，通过 document.getElementById(‘xx’).setAttribute(‘xx’,value) 新增和修改。<br>在标签里定义的所有属性包括 HTML 属性和自定义属性都会在 attributes 对象里以键值对的方式存在。</p><p>例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"pwd"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span> <span class="attr">class</span>=<span class="string">"el-input__inner"</span> <span class="attr">maxlength</span>=<span class="string">"32"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>打印的 attribute 对象（NamedNodeMap 对象表示元素属性节点的无序集合）：<br><img src="/img/namednodemap.png" alt="对象（NamedNodeMap"></p><p>v-bind 默认绑定到 DOM 节点的 attribute 上，使用 .prop 修饰符后，会绑定到 property</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>使用 property 获取最新的值；</li><li>attribute 设置的自定义属性会在渲染后的 HTML 标签里显示，property 不会。</li></ul><h5 id="修饰符用途"><a href="#修饰符用途" class="headerlink" title="修饰符用途"></a>修饰符用途</h5><blockquote><p>通过自定义属性存储变量，避免暴露数据<br>防止污染 HTML 结构</p></blockquote><p>例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"11"</span> <span class="attr">:data</span>=<span class="string">"inputData"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">// 标签结构: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"11"</span> <span class="attr">data</span>=<span class="string">"inputData 的值"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">// input.data === undefined</span><br><span class="line">// input.attributes.data === this.inputData</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"11"</span> <span class="attr">:data.prop</span>=<span class="string">"inputData"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">// 标签结构: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">// input.data === this.inputData</span><br><span class="line">// input.attributes.data === undefined</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue官方教程</a><br><a href="https://segmentfault.com/a/1190000016786254" target="_blank" rel="noopener">Vue修饰符</a></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中watch用法</title>
      <link href="/2019/06/11/vue%E4%B8%ADwatch%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/11/vue%E4%B8%ADwatch%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在vue中，使用watch来响应数据的变化。watch的用法大致有三种。下面代码是watch的一种简单的用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"cityName"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#root'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        cityName: <span class="string">'shanghai'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        cityName(newName, oldName) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>直接写一个监听处理函数，当每次监听到 cityName 值发生改变时，执行函数。也可以在所监听的数据后面直接加字符串形式的方法名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    ...</span><br><span class="line">    watch: &#123;</span><br><span class="line">        cityName: <span class="string">'nameChange'</span></span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="immediate和handler"><a href="#immediate和handler" class="headerlink" title="immediate和handler"></a>immediate和handler</h3><p>这样使用watch时有一个特点，就是当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行。如果我们需要在最初绑定值的时候也执行函数，则就需要用到immediate属性。</p><p>比如当父组件向子组件动态传值时，子组件props首次获取到父组件传来的默认值时，也需要执行函数，此时就需要将immediate设为true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    cityName: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    cityName: &#123;</span><br><span class="line">    　　handler(newName, oldName) &#123;</span><br><span class="line">      　　<span class="comment">// ...</span></span><br><span class="line">    　　&#125;,</span><br><span class="line">    　　immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>监听的数据后面写成对象形式，包含handler方法和immediate，之前我们写的函数其实就是在写这个handler方法；<br>immediate表示在watch中首次绑定的时候，是否执行handler，值为true则表示在watch中声明的时候，就立即执行handler方法，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。</p><h3 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h3><p>当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"cityName.name"</span>/&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    cityName: &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'shanghai'</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    cityName: &#123;</span><br><span class="line">      handler(newName, oldName) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>设置deep: true 则可以监听到cityName.name的变化，此时会给cityName的所有属性都加上这个监听器，当对象属性较多时，每个属性值的变化都会执行handler。如果只需要监听对象中的一个属性值，则可以做以下优化：使用字符串的形式监听对象属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'cityName.name'</span>: &#123;</span><br><span class="line">      handler(newName, oldName) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span>,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样只会给对象的某个特定的属性加监听器。</p><p>数组（一维、多维）的变化不需要通过深度监听，对象数组中对象的属性变化则需要deep深度监听。</p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>position中的sticky</title>
      <link href="/2019/06/11/position%E4%B8%AD%E7%9A%84sticky/"/>
      <url>/2019/06/11/position%E4%B8%AD%E7%9A%84sticky/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS-Position"><a href="#CSS-Position" class="headerlink" title="CSS Position"></a>CSS Position</h3><p>CSS的position有如下几种属性：</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p><h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p><h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform  属性非 none 时，容器由视口改为该祖先。</p><h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。</p><h3 id="position-sticky"><a href="#position-sticky" class="headerlink" title="position:sticky"></a>position:sticky</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:sticky;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">10px</span>; <span class="comment">/* 阈值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>position属性中最有意思的就是sticky了，设置了sticky的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>该元素并不脱离文档流，任然保留元素原本在文档流的位置 </li><li>当元素在容器中被滚动超过指定的偏移值的时候，元素在容器内固定在指定的位置上 </li><li>元素固定的相对偏移是相对于离他最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量<br>他是一个新的css3属性，他的表现类似于position:relative和position:fixed的合体，在目标区域在屏幕中是可见的时候，他的行为就像是position:relative,当目标滚动超出目标区域的时候，他的表现就像是fixed，他会固定在目标的位置。这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。它之所以会出现，也是因为监听scroll事件来实现粘性布局使浏览器进入慢滚动的模式，这与浏览器想要通过硬件加速来提升滚动的体验是相悖的。</li></ul><h4 id="生效条件"><a href="#生效条件" class="headerlink" title="生效条件"></a>生效条件</h4><p>需要注意的是，使用该属性有几个必要条件，否则会失效：</p><ul><li>父元素不能overflow:hidden或者overflow:auto属性。</li><li>必须指定top、bottom、left、right4个值之一，否则只会处于相对定位</li><li>父元素的高度不能低于sticky元素的高度</li><li>sticky元素仅在其父元素内生效</li></ul><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>　　<img src="/img/sticky.png" alt="sticky兼容性"></p>]]></content>
      
      
      <categories>
          
          <category> tech-notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
